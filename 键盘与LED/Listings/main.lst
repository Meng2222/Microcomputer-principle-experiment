C51 COMPILER V9.56.0.0   MAIN                                                              12/16/2017 10:27:03 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRIN
                    -T(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          
   2          /*******************************main.c***********************************/
   3          
   4          #include "HD7279.h"
   5          #include "delay.h"
   6          #include "main.h"
   7          #include "89C51_it.h"
   8          
   9          #ifndef DATA_MEMORY_TEST
  10          
  11          #include "8255.h"
  12          #include "basicIO.h"
  13          #include "decode.h"
  14          #include "p1IO.h"
  15          #include "timer.h"
  16          #include "usart.h"
  17          #include "8254.h"
  18          #include "stepMotor.h"
  19          #include "pwm.h"
  20          #include "brushDcMotor.h"
  21          #include "CS5550.h"
  22          
  23          #endif
  24          
  25          #ifdef DATA_MEMORY_TEST
              
              #include "dataMemory.h"
              
              #endif
  30          
  31          //键盘与LED实验
  32          #ifdef KEY_LED_EXP
              //键盘与LED实验状态枚举变量
              typedef enum
              {
                      //循环左移
                      rollingLeft,
                      //循环右移
                      rollingRight,
                      //所有数码管显示按键输入的数字（0~9）
                      showKeyNumTogether,
                      //数码管显示按键输入数字并在每次输入后左移一位
                      inputRoll2Left,
                      //空闲状态
                      idle
              }ledStatus_t;
              
              void main(void)
              {
              //循环移位的周期数宏定义
              #define ROLL_PERIOD (15)
                      //状态指示变量
                      ledStatus_t idata ledStatus = inputRoll2Left;
                      //循环用计数变量
C51 COMPILER V9.56.0.0   MAIN                                                              12/16/2017 10:27:03 PAGE 2   

                      unsigned char i,j = 0;
                      //按键状态，没有按下时为0xff，按下时为按下按键的编号
                      unsigned char keyState = 0;
                      //循环移位周期变量
                      unsigned char rollPeriod = ROLL_PERIOD;
                      //按键是否按下标志位
                      unsigned char keyFlag = 0;
                      while(1)
                      {
                              //每隔20ms循环一次
                              DelayMs(20);
              
                              //读取按键状态
                              keyState = KeyRead();
              
                              switch(ledStatus)
                              {
                                      //数码管显示内容循环左移
                                      case rollingLeft:
                                              //没有按键按下时循环向左滚动
                                              if(keyState==0xff)
                                              {
                                                      rollPeriod--;
                                                      if(rollPeriod == 0)
                                                      {
                                                              rollPeriod = ROLL_PERIOD;
                                                              //每间隔一个周期发送一个左移命令
                                                              HD7279SendByte(RTL_CYCLE);
                                                      }
                                              }
                                              //按下KEY10时进入所有数码管显示同一数字状态
                                              else if(keyState == KEY10)
                                              {
                                                      rollPeriod = ROLL_PERIOD;
                                                      HD7279SendByte(CMD_RESET);
                                                      ledStatus = showKeyNumTogether;
                                              }
                                      break;
                                      //数码管显示内容循环右移
                                      case rollingRight:
                                              //没有按键按下时数码管显示内容循环右移
                                              if(keyState == 0xff)
                                              {
                                                      rollPeriod--;
                                                      if(rollPeriod == 0)
                                                      {
                                                              rollPeriod = ROLL_PERIOD;
                                                              HD7279SendByte(RTR_CYCLE);
                                                      }
                                              }
                                              //按下KEY10时进入所有数码管显示同一数字状态
                                              else if(keyState == KEY10)
                                              {
                                                      rollPeriod = ROLL_PERIOD;
                                                      HD7279SendByte(CMD_RESET);
                                                      ledStatus = showKeyNumTogether;                         
                                              }
                                      break;
                                      //所有数码管一通显示按下按键对应数字
                                      case showKeyNumTogether:
                                              //根据按键状态显示数字（按键编号与数字对应）
                                              switch(keyState)
C51 COMPILER V9.56.0.0   MAIN                                                              12/16/2017 10:27:03 PAGE 3   

                                              {
                                                      case KEY0:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[0]);
                                                              }
                                                      break;
                                                      case KEY1:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[1]);
                                                              }
                                                      break;
                                                      case KEY2:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[2]);
                                                              }
                                                      break;
                                                      case KEY3:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[3]);
                                                              }
                                                      break;
                                                      case KEY4:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[4]);
                                                              }                                       
                                                      break;
                                                      case KEY5:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[5]);
                                                              }                                       
                                                      break;
                                                      case KEY6:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[6]);
                                                              }                                       
                                                      break;
                                                      case KEY7:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[7]);
                                                              }                                       
                                                      break;
                                                      case KEY8:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[8]);
                                                              }                                       
                                                      break;
                                                      case KEY9:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[9]);
                                                              }                                       
                                                      break;
                                                      default:
C51 COMPILER V9.56.0.0   MAIN                                                              12/16/2017 10:27:03 PAGE 4   

                                                      break;
                                              }       
                                      break;
                                              //每次按键时左移并在最后一位显示对应数字
                                      case inputRoll2Left:
                                              if(keyState!=0xff&&keyFlag==0)
                                              {
                                                      //发送不循环左移命令
                                                      HD7279SendByte(RTL_UNCYL);
                                                      //根据按键状态在最后一位显示对应数字
                                                      switch(keyState)
                                                      {
                                                              case KEY0:
                                                                      LedWrite(LED1, realCode[0]);
                                                              break;
                                                              case KEY1:
                                                                      LedWrite(LED1, realCode[1]);
                                                              break;
                                                              case KEY2:
                                                                      LedWrite(LED1, realCode[2]);
                                                              break;
                                                              case KEY3:
                                                                      LedWrite(LED1, realCode[3]);
                                                              break;
                                                              case KEY4:
                                                                      LedWrite(LED1, realCode[4]);
                                                              break;
                                                              case KEY5:
                                                                      LedWrite(LED1, realCode[5]);
                                                              break;
                                                              case KEY6:
                                                                      LedWrite(LED1, realCode[6]);
                                                              break;
                                                              case KEY7:
                                                                      LedWrite(LED1, realCode[7]);
                                                              break;
                                                              case KEY8:
                                                                      LedWrite(LED1, realCode[8]);
                                                              break;
                                                              case KEY9:
                                                                      LedWrite(LED1, realCode[9]);
                                                              break;
                                                              default:
                                                              break;
                                                      }
                                                      //对按键状态进行置位
                                                      keyFlag = 1;
                                              }
                                              //当没有按键按下时对按键状态进行复位
                                              if(keyState == 0xff&&keyFlag == 1)
                                              {
                                                      keyFlag = 0;
                                              }
                                                      
                                      break;
                                      //空闲状态
                                      case idle:
                                              
                                      break;
                                      default:
                                      break;
                              }
C51 COMPILER V9.56.0.0   MAIN                                                              12/16/2017 10:27:03 PAGE 5   

                      }
              }
              #endif
 244          
 245          //简单IO实验
 246          #ifdef BASIC_IO_EXP
              
              void main(void)
              {
                      //IO输入记录变量
                      unsigned char ioInput = 0;
                      //循环计数用变量
                      unsigned char i = 0;
                      
                      while(1)
                      {
                              //每20MS循环一次
                              DelayMs(20);
                              
                              //从74LS245地址读取简单IO输入
                              ioInput = chip245Adress;
                      
                              //将简单IO输入输出到74LS374
                              chip374Adress = ~ioInput;
                      
                              //在数码管上显示简单IO输入状态 
                              for(i = 0 ; i < 8 ; i++)
                              {
                                      if((ioInput>>i)&0x01)
                                      {
                                              LedWrite(0x97 - 7 + i, realCode[1]);
                                      }
                                      else
                                      {
                                              LedWrite(0x97 - 7 + i, realCode[0]);
                                      }
                              }
                      }
              }
              #endif
 281          
 282          //译码器实验
 283          #ifdef DECODE_EXP
              
              void main(void)
              {
                      //译码实验输出变量
                      unsigned char ioOutput = 0;
                      //计数用变量
                      unsigned short timeCounter = 0;
                      while(1)
                      {
                              //每20ms循环一次
                              DelayMs(20);
                              
                              //记录循环次数
                              timeCounter++;
                              timeCounter%=20;
                              
                              //每隔一定周期将输出输出到不同的地址
                              if(timeCounter/10)
                              {
C51 COMPILER V9.56.0.0   MAIN                                                              12/16/2017 10:27:03 PAGE 6   

                                      decodeAdress1 = ioOutput;
                              }
                              else
                              {
                                      decodeAdress2 = ioOutput;
                              }       
                      }
              }
              #endif
 312          
 313          //通用IOP1实验
 314          #ifdef P1_IO_EXP
              //P1IO实验状态指示枚举变量
              typedef enum
              {
                      //四个LED灯
                      blinkIn4,
                      //流水灯 
                      flow,
                      //LED灯指示开关状态
                      showInput,
                      //空闲状态
                      p1Idle
              }p1IOStatus_t;
              
              void main(void)
              {
                      //状态指示变量
                      p1IOStatus_t idata p1IOStatus = flow;
                      while(1)
                      {
                              //每20ms循环一次
                              DelayMs(20);
                              
                              switch(p1IOStatus)
                              {
                                      //四个LED一组闪烁
                                      case blinkIn4:
                                              BlinkIn4(500);
                                      break;
                                      //流水灯
                                      case flow:
                                              Flow(500);
                                      break;
                                      //将P10~P13输入输出到P14~P17，用输入控制LED的亮灭
                                      case showInput:
                                              ShowInput();
                                      break;
                                      case p1Idle:
                                      break;
                                      default:
                                      break;
                              }       
                      }
              }
              #endif
 359          
 360          //定时器实验
 361          #ifdef TIMER_EXP
              
              //状态指示枚举变量类型
              typedef enum
C51 COMPILER V9.56.0.0   MAIN                                                              12/16/2017 10:27:03 PAGE 7   

              {
                      timerExp1,
                      timerExp2,
                      timerExp3       
              }timerStatus_t;
              
              void main(void)
              {
                      //状态指示变量
                      timerStatus_t idata timerStatus = timerExp3;
                      
                      //实验三是否触发指示变量
                      unsigned char triggerFlag = 0;
                      
                      //实验三脉冲宽度变量
                      unsigned short pulseWidth = 0;
                      
                      //定时器初始化结构体 
                      timeMode_t timeMode ={0};
                      
                      //对结构体进行赋值
                      timeMode.isGateCrl = noGateCrl;
                      timeMode.timeWorkMode = timer;
                      timeMode.timeTriggerMode = innerTrigger;
                      timeMode.timerMode = halfWordAutoReload;
                      
                      //初始化定时器
                      TimeInit(TIM0 , timeMode ,200, TIMERUS);
              
                      //对结构体进行赋值
                      timeMode.isGateCrl = noGateCrl;
                      timeMode.timeWorkMode = counter;
                      timeMode.timeTriggerMode = outerTrigger;
                      timeMode.timerMode = byteAutoReload;
                      //初始化定时器
                      TimeInit(TIM1 , timeMode ,0, TIMERUS);
                      TimerCmd(TIM1 , disable);
                      TH1 = 0xfb;
                      TL1 = 0xfb;
                      TimerCmd(TIM1 ,enable);
                      
                      if(timerStatus==timerExp3)
                      {
                              //对结构体进行赋值      
                              timeMode.isGateCrl = GateCrl;
                              timeMode.timeWorkMode = timer;
                              timeMode.timeTriggerMode = innerTrigger;
                              timeMode.timerMode = halfWordNotReload; 
                              //初始化定时器    
                              TimeInit(TIM1 , timeMode ,65535, 1);
                              TimerCmd(TIM1 , disable);
                      }               
                      while(1)
                      {
                              switch(timerStatus)
                              {
                                      //在P1.0引脚上生成一个周期为400uS的方波
                                      case timerExp1:
                                              if(TimerGetOverFlowITFlag(TIM0))
                                              {
                                                      P10=!P10;
                                                      TimerClearOverFlowFlag(TIM0);
C51 COMPILER V9.56.0.0   MAIN                                                              12/16/2017 10:27:03 PAGE 8   

                                              }
                                      break;
                                      //通过定时器技术控制LED的亮灭
                                      case timerExp2:
                                              {
                                                      if(TimerGetOverFlowITFlag(TIM1))
                                                      {
                                                              P10=!P10;
                                                              TimerClearOverFlowFlag(TIM1);
                                                      }                                                       
                                              }
                                      break;
                                      //测量脉冲宽度
                                      case timerExp3:
                                      {
                                              //输入为高
                                              if(P33==1)
                                              {
                                                      //失能定时器 
                                                      TimerCmd(TIM1 , disable);
                                                      //如果之前被触发计算脉冲宽度
                                                      if(triggerFlag==1)
                                                      {
                                                              //从定时器寄存器中读出脉冲宽度
                                                              pulseWidth = ((TH1<<8)|TL1);
                                                              //在数码管上显示脉冲宽度
                                                              LEDShowInt(pulseWidth);
                                                              //复位标志位及寄存器
                                                              triggerFlag = 0;
                                                              TH1=0;
                                                              TL1=0;
                                                      }
                                              }
                                              //输入为低
                                              else if(P33==0)
                                              {
                                                      //开始计时并对标志位进行置位
                                                      TimerCmd(TIM1 , enable);
                                                      triggerFlag = 1;
                                              }
                                      }
                                      break;
                              }       
                      }
              }
              #endif
 473          
 474          //中断实验
 475          #ifdef INTERRUPT_EXP
              
              //中断实验状态指示枚举变量类型
              typedef enum
              {
                      itExp1,
                      itExp2,
                      itExp3
              }itStatus_t;
              
              //LED状态知识标志位
              unsigned char LedItStatus = 0;
              unsigned char itTimes = 0;
              
C51 COMPILER V9.56.0.0   MAIN                                                              12/16/2017 10:27:03 PAGE 9   

              void main(void)
              {
                      //中断状态指示枚举变量
                      itStatus_t idata itStatus = itExp3;
                      
                      //定时器初始化结构体
                      timeMode_t timeMode ={0};
                      
                      //初始化定时器
                      timeMode.isGateCrl = noGateCrl;
                      timeMode.timeWorkMode = timer;
                      timeMode.timeTriggerMode = innerTrigger;
                      timeMode.timerMode = halfWordAutoReload;
                      
                      TimeInit(TIM0 , timeMode ,5000, TIMERUS);
                      
                      //使能定时器中断
                      TimerOverFlowItInit(TIM0 , enable);
                      
                      //使能外部中断0
                      IT0 = 1;
                      
              
                      while(1)
                      {
                              //每20ms循环一次
                              DelayMs(20);
                              //根据不同中断中的标志切换LED的状态
                              switch(itStatus)
                              {
                                      case itExp1:
                                              if(LedItStatus)
                                              {
                                                      Flow(200);
                                              }
                                              else
                                              {
                                                      BlinkIn4(300);
                                              }
                                      break;
                                      case itExp2:
                                              if(LedItStatus)
                                              {
                                                      Flow(200);
                                              }
                                              else
                                              {
                                                      BlinkIn4(300);
                                              }
                                      break;
                                      case itExp3:
                                              if(LedItStatus)
                                              {
                                                      Flow(200);
                                              }
                                              else
                                              {
                                                      BlinkIn4(300);
                                              }
                                      break;
                              }               
                      }
C51 COMPILER V9.56.0.0   MAIN                                                              12/16/2017 10:27:03 PAGE 10  

              }
              
              #endif
 554          
 555          //数据储存器实验
 556          #ifdef DATA_MEMORY_TEST
              void main(void)
              {
                      //循环用计数变量
                      unsigned char i = 0;
                      //对P1IO的输出状态进行初始化
                      P1 = 0x00;
                      //延时20ms
                      DelayMs(20);
                      while(1)
                      {
                              //配置辅助寄存器
                              AUXR = 0x8e;
                              //对数据进行赋值和显示
                              for(i = 0 ; i < DIRECT_ACCESS_SIZE;i++)
                              {
                                      directAccess[i] = i;
                                      LEDShowInt(directAccess[i]);
                                      DelayMs(300);
                              }
                              for(i = 0; i< BIT_ACCESS_SIZE ; i++)
                              {
                                      bitAccess[i] = 255 - i;
                                      LEDShowInt(bitAccess[i]);
                                      DelayMs(300);           
                              }
                              for(i = 0; i< INDIRECT_ACCESS_SIZE ; i++)
                              {
                                      indirectAccess[i] = 128 + i;
                                      LEDShowInt(indirectAccess[i]);
                                      DelayMs(300);           
                              }
                              for(i = 0; i< PAGE_ACCESS_SIZE ; i++)
                              {
                                      pageAccess[i] = i;
                                      LEDShowInt(pageAccess[i]);
                                      DelayMs(300);           
                              }
                              
                              for(i = 0; i< OUTER_MEM_IN_MCU_SIZE ; i++)
                              {
                                      outerMemInMCU[i] = i;
                                      LEDShowInt(outerMemInMCU[i]);
                                      DelayMs(300);           
                              }
                              //配置辅助寄存器禁止片内扩展RAM区
                              AUXR = 0x02;
                              for(i = 0; i< OUTER_EXTEND_MEM_SIZE ; i++)
                              {
                                      outerExtendMem[i] = 128 - i;
                                      LEDShowInt(outerExtendMem[i]);
                                      DelayMs(300);           
                              }               
                      }
              }
              #endif
 612          
C51 COMPILER V9.56.0.0   MAIN                                                              12/16/2017 10:27:03 PAGE 11  

 613          #ifdef UART_EXP
              unsigned char UART1Recieve = 0;
              
              void main(void)
              {
              //      //对P1IO的输出状态进行初始化
                      
                      UARTMode_t UARTInitStruct = {0};
                      
                      P1 = 0x00;
                      
                      UARTInitStruct.UARTMode = UART_MODE_1;
                      UARTInitStruct.UARTIsMulti = 0;
                      UARTInitStruct.isUARTBaudrateDouble = UART_BAUDRATE_NORMAL;
                      UARTInitStruct.itPriority = 0;
                      
                      UARTInit(UART1,UARTInitStruct,9600);
                      
                      while(1)
                      {
                              DelayMs(20);
                              
                              UARTSendByte(UART1,84);
                              
                              LEDShowInt(UART1Recieve);
                              
                      }
              }
              #endif
 642          
 643          #ifdef IO8255_EXP
              
              void main(void)
              {
                      IO8255Init_t IO8255InitStuct = {0};
                      unsigned char pinNum = 0;
                      
                      IO8255InitStuct.portAInit.IO8255Mode = IO8255_MODE0;
                      IO8255InitStuct.portAInit.IOInOrOut = IO8255_INPUT;
              
                      IO8255InitStuct.portBInit.IO8255Mode = IO8255_MODE0;
                      IO8255InitStuct.portBInit.IOInOrOut = IO8255_OUTPUT;
                      
                      IO8255InitStuct.portCUInit.IOInOrOut = IO8255_OUTPUT;
                      IO8255InitStuct.portCLInit.IOInOrOut = IO8255_OUTPUT;
              
                      IO8255Init(IO8255InitStuct);
                      
                      while(1)
                      {
                              for(pinNum=0 ; pinNum < 8 ; pinNum++)
                              {
                                      IO8255SetBit(PortC , pinNum , IO8255ReadBit(PortA , pinNum));
                              }
              
                      }
              }
              
              #endif
 672          
 673          #ifdef TIMER_8254_EXP
              
C51 COMPILER V9.56.0.0   MAIN                                                              12/16/2017 10:27:03 PAGE 12  

              void main(void)
              {
                      
                      CLK_DIV = (CLK_DIV&0x3f)|0x40;
                      
                      EA = 1;
                      
                      Timer8254CounterModeInit(timer8254Timer0, 10000);
                      
                      Timer8254PrescalerModeInit(timer8254Timer1, 500);
                      
                      StepMotorPinInit();
              
                      ExternalITInit(exIT1 , EXIT_DOWN_TRIGGER);
                      ExternalITCmd(exIT1, enable);
              
                      
                      while(1)
                      {
                      
              //              LEDShowInt(Timer8254GetCounter(timer8254Timer0));
                              DelayMs(20);
                      }
              }
              
              #endif
 701          
 702          #ifdef STEPMOTOR_EXP
              
              extern float xdata actSpeed;
              void main(void)
              {
              //      StepMotorPinInit();
              //      while(1)
              //      {
              //              StepMotorSpeedControl(PI);
              //      }
              //      //定时器初始化结构体 
              //      timeMode_t xdata timeMode ={0};
              //      
              //      //对结构体进行赋值
              //      timeMode.isGateCrl = noGateCrl;
              //      timeMode.timeWorkMode = timer;
              //      timeMode.timeTriggerMode = innerTrigger;
              //      timeMode.timerMode = halfWordAutoReload;
              //      
              //      //初始化定时器
              //      TimeInit(TIM0 , timeMode ,100000, TIMERUS);
              //      
              //      TimerOverFlowItInit(TIM0 , enable);
              
              //              //对结构体进行赋值
              //      timeMode.isGateCrl = noGateCrl;
              //      timeMode.timeWorkMode = counter;
              //      timeMode.timeTriggerMode = innerTrigger;
              //      timeMode.timerMode = halfWordAutoReload;
              //      
              //      //初始化定时器
              //      TimeInit(TIM1 , timeMode ,0, TIMERUS);
              //      
                      PWM0Init();
                      
C51 COMPILER V9.56.0.0   MAIN                                                              12/16/2017 10:27:03 PAGE 13  

                      CCP1Init();
                      
                      PWM0SetCompare(0.5f);
                      PWMCmd(enable);
              //      
              //      DelayMs(5000);
              
              //unsigned long xdata adcGetValue  = 45;
              //unsigned long xdata status = 0;
              //float xdata adcFloat = 0.0f;
              
                      CLK_DIV = (CLK_DIV&0x3f)|0x40;
                      
              //      CS5550WriteCmd(SOFT_RESET_CMD, 0xffffff);
              //      DelayMs(1);
              //      CS5550WriteCmd(SYNC1_CMD, 0xfffffe);
              //      DelayMs(1);
              //      CS5550WriteRes(CONFIG_RES, 0x000011);
              //      DelayMs(1);
              //      CS5550WriteCmd(START_CONTINUE_CONVER_CMD, 0xffffff);
              //      DelayMs(1);     
              //      CS5550WriteRes(CYCLE_COUNT_RES, 0x000138);
              //      DelayMs(2);             
              
                      
                      while(1)
                      {
              //              DelayMs(100);
              //              adcGetValue = CS5550ReadRes(FILT_AIN1_RES);
              //              adcFloat = adcGetValue/(float)0x01000000;
              //              status = CS5550ReadRes(STATUS_RES);
              //              LEDShowFloat(adcFloat);
              //              MotorVelCrl(50.0f,actSpeed);
              //              LEDShowFloat(actSpeed); 
              //              LedWrite(0x97,0x4F);
                      }
              }
              
              #endif
 776          
 777          
 778          #ifdef FINAL_EXAM
 779          
 780          typedef enum
 781          {
 782                  readTemparature,
 783                  readResister
 784          }taskStatus_t;
 785          
 786          
 787          //数码管显示状态枚举类型定义
 788          typedef enum
 789          {
 790                  LEDShowAnalog,
 791                  LEDShowSpeed
 792          }LEDShowStatus_t;
 793          
 794          //float xdata motorSpeed = 0.0f;
 795          //信号量定义
 796          unsigned char xdata semapher = 0;
 797          //引用外部变量电机速度
 798          extern float xdata actSpeed;
C51 COMPILER V9.56.0.0   MAIN                                                              12/16/2017 10:27:03 PAGE 14  

 799          
 800          void main(void)
 801          {
 802   1              //采样电压AD转换结果
 803   1              unsigned long xdata voltageADValue = 0;
 804   1              //AD转换结果符号
 805   1              unsigned char xdata valueSign = 0;
 806   1              //电阻值
 807   1              float xdata resisterValue = 0.0f;
 808   1              //输出电压值
 809   1              float xdata outputVoltage = 0.0f;
 810   1              taskStatus_t xdata taskStatus = readResister;
 811   1              //LED显示状态
 812   1              LEDShowStatus_t xdata LEDShowStatus = LEDShowAnalog;
 813   1              //按键状态
 814   1              unsigned char xdata keyState = 0;
 815   1              //按键是否按下标志位
 816   1              unsigned char xdata keyFlag = 0;
 817   1              //浮点类型变量和无符号8位转换联合体
 818   1              union
 819   1          {
 820   1                      unsigned char u8data[4];
 821   1                      float floatData;
 822   1          }datatransform;
 823   1              
 824   1              //定时器初始化结构体 
 825   1              timeMode_t xdata timeMode ={0};
 826   1              
 827   1              //8255初始化结构体
 828   1              IO8255Init_t xdata IO8255InitStuct = {0};
 829   1              
 830   1              //串口初始化结构体
 831   1              UARTMode_t xdata UARTInitStruct = {0};
 832   1      
 833   1              //时钟输出1分频
 834   1              CLK_DIV = (CLK_DIV&0x3f)|0x40;
 835   1              
 836   1              //8255初始化
 837   1              //端口A模式0输出
 838   1              IO8255InitStuct.portAInit.IO8255Mode = IO8255_MODE0;
 839   1              IO8255InitStuct.portAInit.IOInOrOut = IO8255_OUTPUT;
 840   1              
 841   1              //端口B模式0输入
 842   1              IO8255InitStuct.portBInit.IO8255Mode = IO8255_MODE0;
 843   1              IO8255InitStuct.portBInit.IOInOrOut = IO8255_INPUT;
 844   1              
 845   1              //端口C输出 
 846   1              IO8255InitStuct.portCUInit.IOInOrOut = IO8255_OUTPUT;
 847   1              IO8255InitStuct.portCLInit.IOInOrOut = IO8255_OUTPUT;
 848   1      
 849   1              //8255初始化
 850   1              IO8255Init(IO8255InitStuct);
 851   1              
 852   1              //8254初始化，定时器1作为分频器使用500分频
 853   1              Timer8254PrescalerModeInit(timer8254Timer1, 500);
 854   1              
 855   1              //对定时器初始化结构体进行赋值，无门控，161位自动重装计数器
 856   1              timeMode.isGateCrl = noGateCrl;
 857   1              timeMode.timeWorkMode = counter;
 858   1              timeMode.timerMode = halfWordAutoReload;
 859   1              
 860   1              //初始化定时器
C51 COMPILER V9.56.0.0   MAIN                                                              12/16/2017 10:27:03 PAGE 15  

 861   1              TimeInit(TIM0 , timeMode ,0, TIMERUS);
 862   1              
 863   1              //串口初始化，模式一，无多机通信，波特率不加倍，优先级0
 864   1              UARTInitStruct.UARTMode = UART_MODE_1;
 865   1              UARTInitStruct.UARTIsMulti = 0;
 866   1              UARTInitStruct.isUARTBaudrateDouble = UART_BAUDRATE_NORMAL;
 867   1              UARTInitStruct.itPriority = 0;
 868   1              
 869   1              //串口初始化 波特率9600
 870   1              UARTInit(UART1,UARTInitStruct,9600);
 871   1              
 872   1              //CS5550初始化
 873   1              //软件复位命令
 874   1              CS5550WriteCmd(SOFT_RESET_CMD, 0xffffff);
 875   1              DelayMs(1);
 876   1              //同步命令
 877   1              CS5550WriteCmd(SYNC1_CMD, 0xfffffe);
 878   1              DelayMs(1);
 879   1              //配置config寄存器，增益为10，一分频，反转时钟信号极性减小噪音
 880   1              CS5550WriteRes(CONFIG_RES, 0x000011);
 881   1              DelayMs(1);
 882   1              //开始连续转换
 883   1              CS5550WriteCmd(START_CONTINUE_CONVER_CMD, 0xffffff);
 884   1              DelayMs(1);     
 885   1              //配置计算的周期约为50ms
 886   1              CS5550WriteRes(CYCLE_COUNT_RES, 0x000013);
 887   1              DelayMs(2);
 888   1      
 889   1              //PWM初始化
 890   1              PWM0Init();
 891   1              
 892   1              //PWM占空比配位1，初始输出电压为0
 893   1              PWM0SetCompare(1.0f);
 894   1              //启动PWM输出
 895   1              PWMCmd(enable);         
 896   1              
 897   1              //使能中断
 898   1              EA = 1;
 899   1      
 900   1              //初始化外部中断一为下降沿触发
 901   1              ExternalITInit(exIT1 , EXIT_DOWN_TRIGGER);
 902   1              //使能外部中断1
 903   1              ExternalITCmd(exIT1, enable);
 904   1              
 905   1              
 906   1              while(1)
 907   1              {
 908   2                      //等待信号量
 909   2                      while(semapher==0);
 910   2                      //每次执行对信号量进行清0
 911   2                      semapher = 0;
 912   2                      
 913   2                      //读取按键状态
 914   2                      keyState = KeyRead();
 915   2                      
 916   2                      //按键没有按下时复位按键按下标志
 917   2                      if(keyState==0xff)
 918   2                      {
 919   3                              keyFlag = 0;
 920   3                      }
 921   2                      
 922   2                      //判断按键被按下
C51 COMPILER V9.56.0.0   MAIN                                                              12/16/2017 10:27:03 PAGE 16  

 923   2                      if(keyFlag==0&&keyState!=0xff)
 924   2                      {
 925   3                              //如果为按键0是转换数码管显示内容
 926   3                              if(keyState==KEY0)
 927   3                              {
 928   4                                      if(LEDShowStatus)
 929   4                                      {
 930   5                                              LEDShowStatus = LEDShowAnalog;
 931   5                                      }
 932   4                                      else
 933   4                                      {
 934   5                                              LEDShowStatus = LEDShowSpeed;
 935   5                                      }
 936   4                              }
 937   3                              //对按键按下标志进行置位
 938   3                              keyFlag = 1;
 939   3                      }
 940   2      
 941   2                      //读取AD转换结果
 942   2                      voltageADValue = CS5550ReadRes(FILT_AIN1_RES);
 943   2                      
 944   2                      //将24位数转换为0.0f到1.0f的浮点数
 945   2                      resisterValue = voltageADValue/(float)0x01000000;
 946   2                      
 947   2                      //计算CS5550芯片引脚对应的输入电压（mV）
 948   2                      resisterValue = resisterValue*322.4 + 0.3889;
 949   2      
 950   2                      //计算对应电压通道的输入的电压（mV）
 951   2                      resisterValue = resisterValue/0.0213219;
 952   2                      
 953   2                      //根据电压计算对应电阻值
 954   2                      resisterValue = resisterValue/5000.0f*214.0;
 955   2                      
 956   2                      //计算对应的输出电压
 957   2                      outputVoltage = resisterValue/214.0f * 4.0f + 1.0f;
 958   2                      
 959   2                      //根据要输出的电压计算输出PWM的占空比
 960   2                      PWM0SetCompare((6.51f-outputVoltage)/6.231f);
 961   2                      
 962   2                      //数码管输出
 963   2                      switch(LEDShowStatus)
 964   2                      {
 965   3                              case LEDShowAnalog:
 966   3                                      //模拟量输出浮点数
 967   3                                      LEDShowFloat(resisterValue);
 968   3                                      //第一位显示P.
 969   3                                      LedWrite(0x97,0xe7);
 970   3                                      //将显示的数值通过串口发送
 971   3                                      datatransform.floatData = resisterValue;
 972   3                                      UARTSendByte(UART1,datatransform.u8data[0]);
 973   3                                      UARTSendByte(UART1,datatransform.u8data[1]);
 974   3                                      UARTSendByte(UART1,datatransform.u8data[2]);
 975   3                                      UARTSendByte(UART1,datatransform.u8data[3]);
 976   3                              break;
 977   3                              case LEDShowSpeed:
 978   3                                      //显示速度
 979   3                                      LEDShowInt((unsigned long)(actSpeed/PI/2.0*60.0f));
 980   3                                      //第一位显示S
 981   3                                      LedWrite(0x97,0x5b);
 982   3                                      //将速度通过串口发送
 983   3                                      datatransform.floatData = actSpeed/PI/2.0*60.0f;                                        
 984   3                                      UARTSendByte(UART1,datatransform.u8data[0]);
C51 COMPILER V9.56.0.0   MAIN                                                              12/16/2017 10:27:03 PAGE 17  

 985   3                                      UARTSendByte(UART1,datatransform.u8data[1]);
 986   3                                      UARTSendByte(UART1,datatransform.u8data[2]);
 987   3                                      UARTSendByte(UART1,datatransform.u8data[3]);
 988   3                              break;
 989   3                              default:
 990   3                              break;
 991   3                      }
 992   2      
 993   2                      
 994   2                      
 995   2              }
 996   1      }
 997          
 998          #endif
 999          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    937    ----
   CONSTANT SIZE    =     15    ----
   XDATA SIZE       =      1      32
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
