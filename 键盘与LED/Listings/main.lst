C51 COMPILER V9.56.0.0   MAIN                                                              12/15/2017 20:19:22 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRIN
                    -T(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "HD7279.h"
   2          #include "delay.h"
   3          #include "main.h"
   4          #include "89C51_it.h"
   5          
   6          #ifndef DATA_MEMORY_TEST
   7          
   8          #include "8255.h"
   9          #include "basicIO.h"
  10          #include "decode.h"
  11          #include "p1IO.h"
  12          #include "timer.h"
  13          #include "usart.h"
  14          #include "8254.h"
  15          #include "stepMotor.h"
  16          #include "pwm.h"
  17          #include "brushDcMotor.h"
  18          #include "CS5550.h"
  19          
  20          #endif
  21          
  22          #ifdef DATA_MEMORY_TEST
              
              #include "dataMemory.h"
              
              #endif
  27          
  28          //键盘与LED实验
  29          #ifdef KEY_LED_EXP
              //键盘与LED实验状态枚举变量
              typedef enum
              {
                      //循环左移
                      rollingLeft,
                      //循环右移
                      rollingRight,
                      //所有数码管显示按键输入的数字（0~9）
                      showKeyNumTogether,
                      //数码管显示按键输入数字并在每次输入后左移一位
                      inputRoll2Left,
                      //空闲状态
                      idle
              }ledStatus_t;
              
              void main(void)
              {
              //循环移位的周期数宏定义
              #define ROLL_PERIOD (15)
                      //状态指示变量
                      ledStatus_t idata ledStatus = inputRoll2Left;
                      //循环用计数变量
                      unsigned char i,j = 0;
                      //按键状态，没有按下时为0xff，按下时为按下按键的编号
                      unsigned char keyState = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              12/15/2017 20:19:22 PAGE 2   

                      //循环移位周期变量
                      unsigned char rollPeriod = ROLL_PERIOD;
                      //按键是否按下标志位
                      unsigned char keyFlag = 0;
                      while(1)
                      {
                              //每隔20ms循环一次
                              DelayMs(20);
              
                              //读取按键状态
                              keyState = KeyRead();
              
                              switch(ledStatus)
                              {
                                      //数码管显示内容循环左移
                                      case rollingLeft:
                                              //没有按键按下时循环向左滚动
                                              if(keyState==0xff)
                                              {
                                                      rollPeriod--;
                                                      if(rollPeriod == 0)
                                                      {
                                                              rollPeriod = ROLL_PERIOD;
                                                              //每间隔一个周期发送一个左移命令
                                                              HD7279SendByte(RTL_CYCLE);
                                                      }
                                              }
                                              //按下KEY10时进入所有数码管显示同一数字状态
                                              else if(keyState == KEY10)
                                              {
                                                      rollPeriod = ROLL_PERIOD;
                                                      HD7279SendByte(CMD_RESET);
                                                      ledStatus = showKeyNumTogether;
                                              }
                                      break;
                                      //数码管显示内容循环右移
                                      case rollingRight:
                                              //没有按键按下时数码管显示内容循环右移
                                              if(keyState == 0xff)
                                              {
                                                      rollPeriod--;
                                                      if(rollPeriod == 0)
                                                      {
                                                              rollPeriod = ROLL_PERIOD;
                                                              HD7279SendByte(RTR_CYCLE);
                                                      }
                                              }
                                              //按下KEY10时进入所有数码管显示同一数字状态
                                              else if(keyState == KEY10)
                                              {
                                                      rollPeriod = ROLL_PERIOD;
                                                      HD7279SendByte(CMD_RESET);
                                                      ledStatus = showKeyNumTogether;                         
                                              }
                                      break;
                                      //所有数码管一通显示按下按键对应数字
                                      case showKeyNumTogether:
                                              //根据按键状态显示数字（按键编号与数字对应）
                                              switch(keyState)
                                              {
                                                      case KEY0:
                                                              for(i = 0 ; i < 8 ; i++)
C51 COMPILER V9.56.0.0   MAIN                                                              12/15/2017 20:19:22 PAGE 3   

                                                              {
                                                                      LedWrite(0x97 - i, realCode[0]);
                                                              }
                                                      break;
                                                      case KEY1:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[1]);
                                                              }
                                                      break;
                                                      case KEY2:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[2]);
                                                              }
                                                      break;
                                                      case KEY3:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[3]);
                                                              }
                                                      break;
                                                      case KEY4:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[4]);
                                                              }                                       
                                                      break;
                                                      case KEY5:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[5]);
                                                              }                                       
                                                      break;
                                                      case KEY6:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[6]);
                                                              }                                       
                                                      break;
                                                      case KEY7:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[7]);
                                                              }                                       
                                                      break;
                                                      case KEY8:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[8]);
                                                              }                                       
                                                      break;
                                                      case KEY9:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[9]);
                                                              }                                       
                                                      break;
                                                      default:
                                                      break;
                                              }       
                                      break;
C51 COMPILER V9.56.0.0   MAIN                                                              12/15/2017 20:19:22 PAGE 4   

                                              //每次按键时左移并在最后一位显示对应数字
                                      case inputRoll2Left:
                                              if(keyState!=0xff&&keyFlag==0)
                                              {
                                                      //发送不循环左移命令
                                                      HD7279SendByte(RTL_UNCYL);
                                                      //根据按键状态在最后一位显示对应数字
                                                      switch(keyState)
                                                      {
                                                              case KEY0:
                                                                      LedWrite(LED1, realCode[0]);
                                                              break;
                                                              case KEY1:
                                                                      LedWrite(LED1, realCode[1]);
                                                              break;
                                                              case KEY2:
                                                                      LedWrite(LED1, realCode[2]);
                                                              break;
                                                              case KEY3:
                                                                      LedWrite(LED1, realCode[3]);
                                                              break;
                                                              case KEY4:
                                                                      LedWrite(LED1, realCode[4]);
                                                              break;
                                                              case KEY5:
                                                                      LedWrite(LED1, realCode[5]);
                                                              break;
                                                              case KEY6:
                                                                      LedWrite(LED1, realCode[6]);
                                                              break;
                                                              case KEY7:
                                                                      LedWrite(LED1, realCode[7]);
                                                              break;
                                                              case KEY8:
                                                                      LedWrite(LED1, realCode[8]);
                                                              break;
                                                              case KEY9:
                                                                      LedWrite(LED1, realCode[9]);
                                                              break;
                                                              default:
                                                              break;
                                                      }
                                                      //对按键状态进行置位
                                                      keyFlag = 1;
                                              }
                                              //当没有按键按下时对按键状态进行复位
                                              if(keyState == 0xff&&keyFlag == 1)
                                              {
                                                      keyFlag = 0;
                                              }
                                                      
                                      break;
                                      //空闲状态
                                      case idle:
                                              
                                      break;
                                      default:
                                      break;
                              }
                      }
              }
              #endif
C51 COMPILER V9.56.0.0   MAIN                                                              12/15/2017 20:19:22 PAGE 5   

 241          
 242          //简单IO实验
 243          #ifdef BASIC_IO_EXP
              
              void main(void)
              {
                      //IO输入记录变量
                      unsigned char ioInput = 0;
                      //循环计数用变量
                      unsigned char i = 0;
                      
                      while(1)
                      {
                              //每20MS循环一次
                              DelayMs(20);
                              
                              //从74LS245地址读取简单IO输入
                              ioInput = chip245Adress;
                      
                              //将简单IO输入输出到74LS374
                              chip374Adress = ~ioInput;
                      
                              //在数码管上显示简单IO输入状态 
                              for(i = 0 ; i < 8 ; i++)
                              {
                                      if((ioInput>>i)&0x01)
                                      {
                                              LedWrite(0x97 - 7 + i, realCode[1]);
                                      }
                                      else
                                      {
                                              LedWrite(0x97 - 7 + i, realCode[0]);
                                      }
                              }
                      }
              }
              #endif
 278          
 279          //译码器实验
 280          #ifdef DECODE_EXP
              
              void main(void)
              {
                      //译码实验输出变量
                      unsigned char ioOutput = 0;
                      //计数用变量
                      unsigned short timeCounter = 0;
                      while(1)
                      {
                              //每20ms循环一次
                              DelayMs(20);
                              
                              //记录循环次数
                              timeCounter++;
                              timeCounter%=20;
                              
                              //每隔一定周期将输出输出到不同的地址
                              if(timeCounter/10)
                              {
                                      decodeAdress1 = ioOutput;
                              }
                              else
C51 COMPILER V9.56.0.0   MAIN                                                              12/15/2017 20:19:22 PAGE 6   

                              {
                                      decodeAdress2 = ioOutput;
                              }       
                      }
              }
              #endif
 309          
 310          //通用IOP1实验
 311          #ifdef P1_IO_EXP
              //P1IO实验状态指示枚举变量
              typedef enum
              {
                      //四个LED灯
                      blinkIn4,
                      //流水灯 
                      flow,
                      //LED灯指示开关状态
                      showInput,
                      //空闲状态
                      p1Idle
              }p1IOStatus_t;
              
              void main(void)
              {
                      //状态指示变量
                      p1IOStatus_t idata p1IOStatus = flow;
                      while(1)
                      {
                              //每20ms循环一次
                              DelayMs(20);
                              
                              switch(p1IOStatus)
                              {
                                      //四个LED一组闪烁
                                      case blinkIn4:
                                              BlinkIn4(500);
                                      break;
                                      //流水灯
                                      case flow:
                                              Flow(500);
                                      break;
                                      //将P10~P13输入输出到P14~P17，用输入控制LED的亮灭
                                      case showInput:
                                              ShowInput();
                                      break;
                                      case p1Idle:
                                      break;
                                      default:
                                      break;
                              }       
                      }
              }
              #endif
 356          
 357          //定时器实验
 358          #ifdef TIMER_EXP
              
              //状态指示枚举变量类型
              typedef enum
              {
                      timerExp1,
                      timerExp2,
C51 COMPILER V9.56.0.0   MAIN                                                              12/15/2017 20:19:22 PAGE 7   

                      timerExp3       
              }timerStatus_t;
              
              void main(void)
              {
                      //状态指示变量
                      timerStatus_t idata timerStatus = timerExp3;
                      
                      //实验三是否触发指示变量
                      unsigned char triggerFlag = 0;
                      
                      //实验三脉冲宽度变量
                      unsigned short pulseWidth = 0;
                      
                      //定时器初始化结构体 
                      timeMode_t timeMode ={0};
                      
                      //对结构体进行赋值
                      timeMode.isGateCrl = noGateCrl;
                      timeMode.timeWorkMode = timer;
                      timeMode.timeTriggerMode = innerTrigger;
                      timeMode.timerMode = halfWordAutoReload;
                      
                      //初始化定时器
                      TimeInit(TIM0 , timeMode ,200, TIMERUS);
              
                      //对结构体进行赋值
                      timeMode.isGateCrl = noGateCrl;
                      timeMode.timeWorkMode = counter;
                      timeMode.timeTriggerMode = outerTrigger;
                      timeMode.timerMode = byteAutoReload;
                      //初始化定时器
                      TimeInit(TIM1 , timeMode ,0, TIMERUS);
                      TimerCmd(TIM1 , disable);
                      TH1 = 0xfb;
                      TL1 = 0xfb;
                      TimerCmd(TIM1 ,enable);
                      
                      if(timerStatus==timerExp3)
                      {
                              //对结构体进行赋值      
                              timeMode.isGateCrl = GateCrl;
                              timeMode.timeWorkMode = timer;
                              timeMode.timeTriggerMode = innerTrigger;
                              timeMode.timerMode = halfWordNotReload; 
                              //初始化定时器    
                              TimeInit(TIM1 , timeMode ,65535, 1);
                              TimerCmd(TIM1 , disable);
                      }               
                      while(1)
                      {
                              switch(timerStatus)
                              {
                                      //在P1.0引脚上生成一个周期为400uS的方波
                                      case timerExp1:
                                              if(TimerGetOverFlowITFlag(TIM0))
                                              {
                                                      P10=!P10;
                                                      TimerClearOverFlowFlag(TIM0);
                                              }
                                      break;
                                      //通过定时器技术控制LED的亮灭
C51 COMPILER V9.56.0.0   MAIN                                                              12/15/2017 20:19:22 PAGE 8   

                                      case timerExp2:
                                              {
                                                      if(TimerGetOverFlowITFlag(TIM1))
                                                      {
                                                              P10=!P10;
                                                              TimerClearOverFlowFlag(TIM1);
                                                      }                                                       
                                              }
                                      break;
                                      //测量脉冲宽度
                                      case timerExp3:
                                      {
                                              //输入为高
                                              if(P33==1)
                                              {
                                                      //失能定时器 
                                                      TimerCmd(TIM1 , disable);
                                                      //如果之前被触发计算脉冲宽度
                                                      if(triggerFlag==1)
                                                      {
                                                              //从定时器寄存器中读出脉冲宽度
                                                              pulseWidth = ((TH1<<8)|TL1);
                                                              //在数码管上显示脉冲宽度
                                                              LEDShowInt(pulseWidth);
                                                              //复位标志位及寄存器
                                                              triggerFlag = 0;
                                                              TH1=0;
                                                              TL1=0;
                                                      }
                                              }
                                              //输入为低
                                              else if(P33==0)
                                              {
                                                      //开始计时并对标志位进行置位
                                                      TimerCmd(TIM1 , enable);
                                                      triggerFlag = 1;
                                              }
                                      }
                                      break;
                              }       
                      }
              }
              #endif
 470          
 471          //中断实验
 472          #ifdef INTERRUPT_EXP
              
              //中断实验状态指示枚举变量类型
              typedef enum
              {
                      itExp1,
                      itExp2,
                      itExp3
              }itStatus_t;
              
              //LED状态知识标志位
              unsigned char LedItStatus = 0;
              unsigned char itTimes = 0;
              
              void main(void)
              {
                      //中断状态指示枚举变量
C51 COMPILER V9.56.0.0   MAIN                                                              12/15/2017 20:19:22 PAGE 9   

                      itStatus_t idata itStatus = itExp3;
                      
                      //定时器初始化结构体
                      timeMode_t timeMode ={0};
                      
                      //初始化定时器
                      timeMode.isGateCrl = noGateCrl;
                      timeMode.timeWorkMode = timer;
                      timeMode.timeTriggerMode = innerTrigger;
                      timeMode.timerMode = halfWordAutoReload;
                      
                      TimeInit(TIM0 , timeMode ,5000, TIMERUS);
                      
                      //使能定时器中断
                      TimerOverFlowItInit(TIM0 , enable);
                      
                      //使能外部中断0
                      IT0 = 1;
                      
              
                      while(1)
                      {
                              //每20ms循环一次
                              DelayMs(20);
                              //根据不同中断中的标志切换LED的状态
                              switch(itStatus)
                              {
                                      case itExp1:
                                              if(LedItStatus)
                                              {
                                                      Flow(200);
                                              }
                                              else
                                              {
                                                      BlinkIn4(300);
                                              }
                                      break;
                                      case itExp2:
                                              if(LedItStatus)
                                              {
                                                      Flow(200);
                                              }
                                              else
                                              {
                                                      BlinkIn4(300);
                                              }
                                      break;
                                      case itExp3:
                                              if(LedItStatus)
                                              {
                                                      Flow(200);
                                              }
                                              else
                                              {
                                                      BlinkIn4(300);
                                              }
                                      break;
                              }               
                      }
              }
              
              #endif
C51 COMPILER V9.56.0.0   MAIN                                                              12/15/2017 20:19:22 PAGE 10  

 551          
 552          //数据储存器实验
 553          #ifdef DATA_MEMORY_TEST
              void main(void)
              {
                      //循环用计数变量
                      unsigned char i = 0;
                      //对P1IO的输出状态进行初始化
                      P1 = 0x00;
                      //延时20ms
                      DelayMs(20);
                      while(1)
                      {
                              //配置辅助寄存器
                              AUXR = 0x8e;
                              //对数据进行赋值和显示
                              for(i = 0 ; i < DIRECT_ACCESS_SIZE;i++)
                              {
                                      directAccess[i] = i;
                                      LEDShowInt(directAccess[i]);
                                      DelayMs(300);
                              }
                              for(i = 0; i< BIT_ACCESS_SIZE ; i++)
                              {
                                      bitAccess[i] = 255 - i;
                                      LEDShowInt(bitAccess[i]);
                                      DelayMs(300);           
                              }
                              for(i = 0; i< INDIRECT_ACCESS_SIZE ; i++)
                              {
                                      indirectAccess[i] = 128 + i;
                                      LEDShowInt(indirectAccess[i]);
                                      DelayMs(300);           
                              }
                              for(i = 0; i< PAGE_ACCESS_SIZE ; i++)
                              {
                                      pageAccess[i] = i;
                                      LEDShowInt(pageAccess[i]);
                                      DelayMs(300);           
                              }
                              
                              for(i = 0; i< OUTER_MEM_IN_MCU_SIZE ; i++)
                              {
                                      outerMemInMCU[i] = i;
                                      LEDShowInt(outerMemInMCU[i]);
                                      DelayMs(300);           
                              }
                              //配置辅助寄存器禁止片内扩展RAM区
                              AUXR = 0x02;
                              for(i = 0; i< OUTER_EXTEND_MEM_SIZE ; i++)
                              {
                                      outerExtendMem[i] = 128 - i;
                                      LEDShowInt(outerExtendMem[i]);
                                      DelayMs(300);           
                              }               
                      }
              }
              #endif
 609          
 610          #ifdef UART_EXP
              unsigned char UART1Recieve = 0;
              
C51 COMPILER V9.56.0.0   MAIN                                                              12/15/2017 20:19:22 PAGE 11  

              void main(void)
              {
              //      //对P1IO的输出状态进行初始化
                      
                      UARTMode_t UARTInitStruct = {0};
                      
                      P1 = 0x00;
                      
                      UARTInitStruct.UARTMode = UART_MODE_1;
                      UARTInitStruct.UARTIsMulti = 0;
                      UARTInitStruct.isUARTBaudrateDouble = UART_BAUDRATE_NORMAL;
                      UARTInitStruct.itPriority = 0;
                      
                      UARTInit(UART1,UARTInitStruct,9600);
                      
                      while(1)
                      {
                              DelayMs(20);
                              
                              UARTSendByte(UART1,84);
                              
                              LEDShowInt(UART1Recieve);
                              
                      }
              }
              #endif
 639          
 640          #ifdef IO8255_EXP
              
              void main(void)
              {
                      IO8255Init_t IO8255InitStuct = {0};
                      unsigned char pinNum = 0;
                      
                      IO8255InitStuct.portAInit.IO8255Mode = IO8255_MODE0;
                      IO8255InitStuct.portAInit.IOInOrOut = IO8255_INPUT;
              
                      IO8255InitStuct.portBInit.IO8255Mode = IO8255_MODE0;
                      IO8255InitStuct.portBInit.IOInOrOut = IO8255_OUTPUT;
                      
                      IO8255InitStuct.portCUInit.IOInOrOut = IO8255_OUTPUT;
                      IO8255InitStuct.portCLInit.IOInOrOut = IO8255_OUTPUT;
              
                      IO8255Init(IO8255InitStuct);
                      
                      while(1)
                      {
                              for(pinNum=0 ; pinNum < 8 ; pinNum++)
                              {
                                      IO8255SetBit(PortC , pinNum , IO8255ReadBit(PortA , pinNum));
                              }
              
                      }
              }
              
              #endif
 669          
 670          #ifdef TIMER_8254_EXP
              
              void main(void)
              {
                      
C51 COMPILER V9.56.0.0   MAIN                                                              12/15/2017 20:19:22 PAGE 12  

                      CLK_DIV = (CLK_DIV&0x3f)|0x40;
                      
                      EA = 1;
                      
                      Timer8254CounterModeInit(timer8254Timer0, 10000);
                      
                      Timer8254PrescalerModeInit(timer8254Timer1, 500);
                      
                      StepMotorPinInit();
              
                      ExternalITInit(exIT1 , EXIT_DOWN_TRIGGER);
                      ExternalITCmd(exIT1, enable);
              
                      
                      while(1)
                      {
                      
              //              LEDShowInt(Timer8254GetCounter(timer8254Timer0));
                              DelayMs(20);
                      }
              }
              
              #endif
 698          
 699          #ifdef STEPMOTOR_EXP
              
              extern float xdata actSpeed;
              void main(void)
              {
              //      StepMotorPinInit();
              //      while(1)
              //      {
              //              StepMotorSpeedControl(PI);
              //      }
              //      //定时器初始化结构体 
              //      timeMode_t xdata timeMode ={0};
              //      
              //      //对结构体进行赋值
              //      timeMode.isGateCrl = noGateCrl;
              //      timeMode.timeWorkMode = timer;
              //      timeMode.timeTriggerMode = innerTrigger;
              //      timeMode.timerMode = halfWordAutoReload;
              //      
              //      //初始化定时器
              //      TimeInit(TIM0 , timeMode ,100000, TIMERUS);
              //      
              //      TimerOverFlowItInit(TIM0 , enable);
              
              //              //对结构体进行赋值
              //      timeMode.isGateCrl = noGateCrl;
              //      timeMode.timeWorkMode = counter;
              //      timeMode.timeTriggerMode = innerTrigger;
              //      timeMode.timerMode = halfWordAutoReload;
              //      
              //      //初始化定时器
              //      TimeInit(TIM1 , timeMode ,0, TIMERUS);
              //      
                      PWM0Init();
                      
                      CCP1Init();
                      
                      PWM0SetCompare(0.5f);
C51 COMPILER V9.56.0.0   MAIN                                                              12/15/2017 20:19:22 PAGE 13  

                      PWMCmd(enable);
              //      
              //      DelayMs(5000);
              
              //unsigned long xdata adcGetValue  = 45;
              //unsigned long xdata status = 0;
              //float xdata adcFloat = 0.0f;
              
                      CLK_DIV = (CLK_DIV&0x3f)|0x40;
                      
              //      CS5550WriteCmd(SOFT_RESET_CMD, 0xffffff);
              //      DelayMs(1);
              //      CS5550WriteCmd(SYNC1_CMD, 0xfffffe);
              //      DelayMs(1);
              //      CS5550WriteRes(CONFIG_RES, 0x000011);
              //      DelayMs(1);
              //      CS5550WriteCmd(START_CONTINUE_CONVER_CMD, 0xffffff);
              //      DelayMs(1);     
              //      CS5550WriteRes(CYCLE_COUNT_RES, 0x000138);
              //      DelayMs(2);             
              
                      
                      while(1)
                      {
              //              DelayMs(100);
              //              adcGetValue = CS5550ReadRes(FILT_AIN1_RES);
              //              adcFloat = adcGetValue/(float)0x01000000;
              //              status = CS5550ReadRes(STATUS_RES);
              //              LEDShowFloat(adcFloat);
              //              MotorVelCrl(50.0f,actSpeed);
              //              LEDShowFloat(actSpeed); 
              //              LedWrite(0x97,0x4F);
                      }
              }
              
              #endif
 773          
 774          
 775          #ifdef FINAL_EXAM
 776          
 777          typedef enum
 778          {
 779                  readTemparature,
 780                  readResister
 781          }taskStatus_t;
 782          
 783          typedef enum
 784          {
 785                  LEDShowAnalog,
 786                  LEDShowSpeed
 787          }LEDShowStatus_t;
 788          
 789          //float xdata motorSpeed = 0.0f;
 790          unsigned char xdata semapher = 0;
 791          extern float xdata actSpeed;
 792          
 793          void main(void)
 794          {
 795   1      
 796   1      //      unsigned long xdata tempraturADValue  = 0;
 797   1              unsigned long xdata voltageADValue = 0;
 798   1              unsigned char xdata valueSign = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              12/15/2017 20:19:22 PAGE 14  

 799   1      //      float xdata temprature = 0.0f;
 800   1              float xdata resisterValue = 0.0f;
 801   1              float xdata outputVoltage = 0.0f;
 802   1              taskStatus_t xdata taskStatus = readResister;
 803   1              LEDShowStatus_t xdata LEDShowStatus = LEDShowAnalog;
 804   1              unsigned char xdata keyState = 0;
 805   1              unsigned char xdata keyFlag = 0;
 806   1              union
 807   1          {
 808   1                      unsigned char u8data[4];
 809   1                      float floatData;
 810   1          }datatransform;
 811   1              
 812   1              //定时器初始化结构体 
 813   1              timeMode_t xdata timeMode ={0};
 814   1              
 815   1              //8255初始化结构体
 816   1              IO8255Init_t xdata IO8255InitStuct = {0};
 817   1              
 818   1              //串口初始化结构体
 819   1              UARTMode_t xdata UARTInitStruct = {0};
 820   1      
 821   1              //时钟输出1分频
 822   1              CLK_DIV = (CLK_DIV&0x3f)|0x40;
 823   1              
 824   1              //8255初始化
 825   1              IO8255InitStuct.portAInit.IO8255Mode = IO8255_MODE0;
 826   1              IO8255InitStuct.portAInit.IOInOrOut = IO8255_OUTPUT;
 827   1      
 828   1              IO8255InitStuct.portBInit.IO8255Mode = IO8255_MODE0;
 829   1              IO8255InitStuct.portBInit.IOInOrOut = IO8255_INPUT;
 830   1              
 831   1              IO8255InitStuct.portCUInit.IOInOrOut = IO8255_OUTPUT;
 832   1              IO8255InitStuct.portCLInit.IOInOrOut = IO8255_OUTPUT;
 833   1      
 834   1              IO8255Init(IO8255InitStuct);
 835   1              
 836   1      //      //8254初始化
 837   1              Timer8254PrescalerModeInit(timer8254Timer1, 500);
 838   1              
 839   1              //对结构体进行赋值
 840   1              timeMode.isGateCrl = noGateCrl;
 841   1              timeMode.timeWorkMode = counter;
 842   1              timeMode.timeTriggerMode = innerTrigger;
 843   1              timeMode.timerMode = halfWordAutoReload;
 844   1              
 845   1              //初始化定时器
 846   1              TimeInit(TIM0 , timeMode ,0, TIMERUS);
 847   1      //      
 848   1              //串口初始化
 849   1              UARTInitStruct.UARTMode = UART_MODE_1;
 850   1              UARTInitStruct.UARTIsMulti = 0;
 851   1              UARTInitStruct.isUARTBaudrateDouble = UART_BAUDRATE_NORMAL;
 852   1              UARTInitStruct.itPriority = 0;
 853   1              
 854   1              UARTInit(UART1,UARTInitStruct,9600);
 855   1      //      
 856   1              //CS5550初始化
 857   1              CS5550WriteCmd(SOFT_RESET_CMD, 0xffffff);
 858   1              DelayMs(1);
 859   1              CS5550WriteCmd(SYNC1_CMD, 0xfffffe);
 860   1              DelayMs(1);
C51 COMPILER V9.56.0.0   MAIN                                                              12/15/2017 20:19:22 PAGE 15  

 861   1              CS5550WriteRes(CONFIG_RES, 0x000011);
 862   1              DelayMs(1);
 863   1              CS5550WriteCmd(START_CONTINUE_CONVER_CMD, 0xffffff);
 864   1              DelayMs(1);     
 865   1              CS5550WriteRes(CYCLE_COUNT_RES, 0x000138);
 866   1              DelayMs(2);
 867   1      
 868   1              //PWM初始化
 869   1              PWM0Init();
 870   1              
 871   1              PWM0SetCompare(0.0f);
 872   1              PWMCmd(enable);         
 873   1              
 874   1              EA = 1;
 875   1      //      
 876   1      ////    StepMotorPinInit();
 877   1      
 878   1              ExternalITInit(exIT1 , EXIT_DOWN_TRIGGER);
 879   1              ExternalITCmd(exIT1, enable);
 880   1              
 881   1              
 882   1              while(1)
 883   1              {
 884   2                      while(semapher==0);
 885   2                      
 886   2                      //读取按键状态
 887   2                      keyState = KeyRead();
 888   2                      
 889   2                      if(keyState==0xff)
 890   2                      {
 891   3                              keyFlag = 0;
 892   3                      }               
 893   2                      if(keyFlag==0&&keyState!=0xff)
 894   2                      {
 895   3                              if(keyState==KEY0)
 896   3                              {
 897   4                                      if(LEDShowStatus)
 898   4                                      {
 899   5                                              LEDShowStatus = LEDShowAnalog;
 900   5                                      }
 901   4                                      else
 902   4                                      {
 903   5                                              LEDShowStatus = LEDShowSpeed;
 904   5                                      }
 905   4                              }
 906   3                              keyFlag = 1;
 907   3                      }
 908   2      
 909   2                      voltageADValue = CS5550ReadRes(FILT_AIN1_RES);
 910   2      
 911   2                      resisterValue = voltageADValue/(float)0x01000000;
 912   2      
 913   2                      resisterValue = resisterValue*322.4 + 0.3889;
 914   2      
 915   2                      resisterValue = resisterValue/0.0213219;
 916   2      
 917   2                      resisterValue = resisterValue/5000.0f*214.0;
 918   2      
 919   2                      outputVoltage = resisterValue/214.0f * 4.0f + 1.0f;
 920   2      
 921   2                      PWM0SetCompare((6.51f-outputVoltage)/6.231f);
 922   2                      
C51 COMPILER V9.56.0.0   MAIN                                                              12/15/2017 20:19:22 PAGE 16  

 923   2                      switch(LEDShowStatus)
 924   2                      {
 925   3                              case LEDShowAnalog:
 926   3                                      LEDShowFloat(resisterValue);
 927   3                                      LedWrite(0x97,0xe7);                                            
 928   3                                      datatransform.floatData = resisterValue;
 929   3                                      UARTSendByte(UART1,datatransform.u8data[0]);
 930   3                                      UARTSendByte(UART1,datatransform.u8data[1]);
 931   3                                      UARTSendByte(UART1,datatransform.u8data[2]);
 932   3                                      UARTSendByte(UART1,datatransform.u8data[3]);
 933   3      
 934   3      
 935   3                              break;
 936   3                              case LEDShowSpeed:
 937   3                                      LEDShowFloat(actSpeed/PI/2.0*60.0f);
 938   3                                      LedWrite(0x97,0x5b);                                            
 939   3                                      datatransform.floatData = actSpeed/PI/2.0*60.0f;                                        
 940   3                                      UARTSendByte(UART1,datatransform.u8data[0]);
 941   3                                      UARTSendByte(UART1,datatransform.u8data[1]);
 942   3                                      UARTSendByte(UART1,datatransform.u8data[2]);
 943   3                                      UARTSendByte(UART1,datatransform.u8data[3]);                    
 944   3                                      
 945   3                              break;
 946   3                              default:
 947   3                              break;
 948   3                      }
 949   2      
 950   2                      
 951   2                      
 952   2              }
 953   1      }
 954          
 955          #endif
 956          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    932    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =      1      33
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
