C51 COMPILER V9.56.0.0   MAIN                                                              11/06/2017 22:09:35 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRIN
                    -T(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "HD7279.h"
   2          #include "delay.h"
   3          #include "main.h"
   4          #include "89C51_it.h"
   5          
   6          #ifndef DATA_MEMORY_TEST
   7          
   8          #include "basicIO.h"
   9          #include "decode.h"
  10          #include "p1IO.h"
  11          #include "timer.h"
  12          #include "usart.h"
  13          
  14          #endif
  15          
  16          #ifdef DATA_MEMORY_TEST
              
              #include "dataMemory.h"
              
              #endif
  21          
  22          //键盘与LED实验
  23          #ifdef KEY_LED_EXP
              //键盘与LED实验状态枚举变量
              typedef enum
              {
                      //循环左移
                      rollingLeft,
                      //循环右移
                      rollingRight,
                      //所有数码管显示按键输入的数字（0~9）
                      showKeyNumTogether,
                      //数码管显示按键输入数字并在每次输入后左移一位
                      inputRoll2Left,
                      //空闲状态
                      idle
              }ledStatus_t;
              
              void main(void)
              {
              //循环移位的周期数宏定义
              #define ROLL_PERIOD (15)
                      //状态指示变量
                      ledStatus_t idata ledStatus = inputRoll2Left;
                      //循环用计数变量
                      unsigned char i,j = 0;
                      //按键状态，没有按下时为0xff，按下时为按下按键的编号
                      unsigned char keyState = 0;
                      //循环移位周期变量
                      unsigned char rollPeriod = ROLL_PERIOD;
                      //按键是否按下标志位
                      unsigned char keyFlag = 0;
                      while(1)
                      {
C51 COMPILER V9.56.0.0   MAIN                                                              11/06/2017 22:09:35 PAGE 2   

                              //每隔20ms循环一次
                              DelayMs(20);
              
                              //读取按键状态
                              keyState = KeyRead();
              
                              switch(ledStatus)
                              {
                                      //数码管显示内容循环左移
                                      case rollingLeft:
                                              //没有按键按下时循环向左滚动
                                              if(keyState==0xff)
                                              {
                                                      rollPeriod--;
                                                      if(rollPeriod == 0)
                                                      {
                                                              rollPeriod = ROLL_PERIOD;
                                                              //每间隔一个周期发送一个左移命令
                                                              HD7279SendByte(RTL_CYCLE);
                                                      }
                                              }
                                              //按下KEY10时进入所有数码管显示同一数字状态
                                              else if(keyState == KEY10)
                                              {
                                                      rollPeriod = ROLL_PERIOD;
                                                      HD7279SendByte(CMD_RESET);
                                                      ledStatus = showKeyNumTogether;
                                              }
                                      break;
                                      //数码管显示内容循环右移
                                      case rollingRight:
                                              //没有按键按下时数码管显示内容循环右移
                                              if(keyState == 0xff)
                                              {
                                                      rollPeriod--;
                                                      if(rollPeriod == 0)
                                                      {
                                                              rollPeriod = ROLL_PERIOD;
                                                              HD7279SendByte(RTR_CYCLE);
                                                      }
                                              }
                                              //按下KEY10时进入所有数码管显示同一数字状态
                                              else if(keyState == KEY10)
                                              {
                                                      rollPeriod = ROLL_PERIOD;
                                                      HD7279SendByte(CMD_RESET);
                                                      ledStatus = showKeyNumTogether;                         
                                              }
                                      break;
                                      //所有数码管一通显示按下按键对应数字
                                      case showKeyNumTogether:
                                              //根据按键状态显示数字（按键编号与数字对应）
                                              switch(keyState)
                                              {
                                                      case KEY0:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[0]);
                                                              }
                                                      break;
                                                      case KEY1:
                                                              for(i = 0 ; i < 8 ; i++)
C51 COMPILER V9.56.0.0   MAIN                                                              11/06/2017 22:09:35 PAGE 3   

                                                              {
                                                                      LedWrite(0x97 - i, realCode[1]);
                                                              }
                                                      break;
                                                      case KEY2:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[2]);
                                                              }
                                                      break;
                                                      case KEY3:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[3]);
                                                              }
                                                      break;
                                                      case KEY4:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[4]);
                                                              }                                       
                                                      break;
                                                      case KEY5:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[5]);
                                                              }                                       
                                                      break;
                                                      case KEY6:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[6]);
                                                              }                                       
                                                      break;
                                                      case KEY7:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[7]);
                                                              }                                       
                                                      break;
                                                      case KEY8:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[8]);
                                                              }                                       
                                                      break;
                                                      case KEY9:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[9]);
                                                              }                                       
                                                      break;
                                                      default:
                                                      break;
                                              }       
                                      break;
                                              //每次按键时左移并在最后一位显示对应数字
                                      case inputRoll2Left:
                                              if(keyState!=0xff&&keyFlag==0)
                                              {
                                                      //发送不循环左移命令
                                                      HD7279SendByte(RTL_UNCYL);
C51 COMPILER V9.56.0.0   MAIN                                                              11/06/2017 22:09:35 PAGE 4   

                                                      //根据按键状态在最后一位显示对应数字
                                                      switch(keyState)
                                                      {
                                                              case KEY0:
                                                                      LedWrite(LED1, realCode[0]);
                                                              break;
                                                              case KEY1:
                                                                      LedWrite(LED1, realCode[1]);
                                                              break;
                                                              case KEY2:
                                                                      LedWrite(LED1, realCode[2]);
                                                              break;
                                                              case KEY3:
                                                                      LedWrite(LED1, realCode[3]);
                                                              break;
                                                              case KEY4:
                                                                      LedWrite(LED1, realCode[4]);
                                                              break;
                                                              case KEY5:
                                                                      LedWrite(LED1, realCode[5]);
                                                              break;
                                                              case KEY6:
                                                                      LedWrite(LED1, realCode[6]);
                                                              break;
                                                              case KEY7:
                                                                      LedWrite(LED1, realCode[7]);
                                                              break;
                                                              case KEY8:
                                                                      LedWrite(LED1, realCode[8]);
                                                              break;
                                                              case KEY9:
                                                                      LedWrite(LED1, realCode[9]);
                                                              break;
                                                              default:
                                                              break;
                                                      }
                                                      //对按键状态进行置位
                                                      keyFlag = 1;
                                              }
                                              //当没有按键按下时对按键状态进行复位
                                              if(keyState == 0xff&&keyFlag == 1)
                                              {
                                                      keyFlag = 0;
                                              }
                                                      
                                      break;
                                      //空闲状态
                                      case idle:
                                              
                                      break;
                                      default:
                                      break;
                              }
                      }
              }
              #endif
 235          
 236          //简单IO实验
 237          #ifdef BASIC_IO_EXP
              
              void main(void)
              {
C51 COMPILER V9.56.0.0   MAIN                                                              11/06/2017 22:09:35 PAGE 5   

                      //IO输入记录变量
                      unsigned char ioInput = 0;
                      //循环计数用变量
                      unsigned char i = 0;
                      
                      while(1)
                      {
                              //每20MS循环一次
                              DelayMs(20);
                              
                              //从74LS245地址读取简单IO输入
                              ioInput = chip245Adress;
                      
                              //将简单IO输入输出到74LS374
                              chip374Adress = ~ioInput;
                      
                              //在数码管上显示简单IO输入状态 
                              for(i = 0 ; i < 8 ; i++)
                              {
                                      if((ioInput>>i)&0x01)
                                      {
                                              LedWrite(0x97 - 7 + i, realCode[1]);
                                      }
                                      else
                                      {
                                              LedWrite(0x97 - 7 + i, realCode[0]);
                                      }
                              }
                      }
              }
              #endif
 272          
 273          //译码器实验
 274          #ifdef DECODE_EXP
              
              void main(void)
              {
                      //译码实验输出变量
                      unsigned char ioOutput = 0;
                      //计数用变量
                      unsigned short timeCounter = 0;
                      while(1)
                      {
                              //每20ms循环一次
                              DelayMs(20);
                              
                              //记录循环次数
                              timeCounter++;
                              timeCounter%=20;
                              
                              //每隔一定周期将输出输出到不同的地址
                              if(timeCounter/10)
                              {
                                      decodeAdress1 = ioOutput;
                              }
                              else
                              {
                                      decodeAdress2 = ioOutput;
                              }       
                      }
              }
              #endif
C51 COMPILER V9.56.0.0   MAIN                                                              11/06/2017 22:09:35 PAGE 6   

 303          
 304          //通用IOP1实验
 305          #ifdef P1_IO_EXP
              //P1IO实验状态指示枚举变量
              typedef enum
              {
                      //四个LED灯
                      blinkIn4,
                      //流水灯 
                      flow,
                      //LED灯指示开关状态
                      showInput,
                      //空闲状态
                      p1Idle
              }p1IOStatus_t;
              
              void main(void)
              {
                      //状态指示变量
                      p1IOStatus_t idata p1IOStatus = flow;
                      while(1)
                      {
                              //每20ms循环一次
                              DelayMs(20);
                              
                              switch(p1IOStatus)
                              {
                                      //四个LED一组闪烁
                                      case blinkIn4:
                                              BlinkIn4(500);
                                      break;
                                      //流水灯
                                      case flow:
                                              Flow(500);
                                      break;
                                      //将P10~P13输入输出到P14~P17，用输入控制LED的亮灭
                                      case showInput:
                                              ShowInput();
                                      break;
                                      case p1Idle:
                                      break;
                                      default:
                                      break;
                              }       
                      }
              }
              #endif
 350          
 351          //定时器实验
 352          #ifdef TIMER_EXP
              
              //状态指示枚举变量类型
              typedef enum
              {
                      timerExp1,
                      timerExp2,
                      timerExp3       
              }timerStatus_t;
              
              void main(void)
              {
                      //状态指示变量
C51 COMPILER V9.56.0.0   MAIN                                                              11/06/2017 22:09:35 PAGE 7   

                      timerStatus_t idata timerStatus = timerExp3;
                      
                      //实验三是否触发指示变量
                      unsigned char triggerFlag = 0;
                      
                      //实验三脉冲宽度变量
                      unsigned short pulseWidth = 0;
                      
                      //定时器初始化结构体 
                      timeMode_t timeMode ={0};
                      
                      //对结构体进行赋值
                      timeMode.isGateCrl = noGateCrl;
                      timeMode.timeWorkMode = timer;
                      timeMode.timeTriggerMode = innerTrigger;
                      timeMode.timerMode = halfWordAutoReload;
                      
                      //初始化定时器
                      TimeInit(TIM0 , timeMode ,200, TIMERUS);
              
                      //对结构体进行赋值
                      timeMode.isGateCrl = noGateCrl;
                      timeMode.timeWorkMode = counter;
                      timeMode.timeTriggerMode = outerTrigger;
                      timeMode.timerMode = byteAutoReload;
                      //初始化定时器
                      TimeInit(TIM1 , timeMode ,0, TIMERUS);
                      TimerCmd(TIM1 , disable);
                      TH1 = 0xfb;
                      TL1 = 0xfb;
                      TimerCmd(TIM1 ,enable);
                      
                      if(timerStatus==timerExp3)
                      {
                              //对结构体进行赋值      
                              timeMode.isGateCrl = GateCrl;
                              timeMode.timeWorkMode = timer;
                              timeMode.timeTriggerMode = innerTrigger;
                              timeMode.timerMode = halfWordNotReload; 
                              //初始化定时器    
                              TimeInit(TIM1 , timeMode ,65535, 1);
                              TimerCmd(TIM1 , disable);
                      }               
                      while(1)
                      {
                              switch(timerStatus)
                              {
                                      //在P1.0引脚上生成一个周期为400uS的方波
                                      case timerExp1:
                                              if(TimerGetOverFlowITFlag(TIM0))
                                              {
                                                      P10=!P10;
                                                      TimerClearOverFlowFlag(TIM0);
                                              }
                                      break;
                                      //通过定时器技术控制LED的亮灭
                                      case timerExp2:
                                              {
                                                      if(TimerGetOverFlowITFlag(TIM1))
                                                      {
                                                              P10=!P10;
                                                              TimerClearOverFlowFlag(TIM1);
C51 COMPILER V9.56.0.0   MAIN                                                              11/06/2017 22:09:35 PAGE 8   

                                                      }                                                       
                                              }
                                      break;
                                      //测量脉冲宽度
                                      case timerExp3:
                                      {
                                              //输入为高
                                              if(P33==1)
                                              {
                                                      //失能定时器 
                                                      TimerCmd(TIM1 , disable);
                                                      //如果之前被触发计算脉冲宽度
                                                      if(triggerFlag==1)
                                                      {
                                                              //从定时器寄存器中读出脉冲宽度
                                                              pulseWidth = ((TH1<<8)|TL1);
                                                              //在数码管上显示脉冲宽度
                                                              LEDShowInt(pulseWidth);
                                                              //复位标志位及寄存器
                                                              triggerFlag = 0;
                                                              TH1=0;
                                                              TL1=0;
                                                      }
                                              }
                                              //输入为低
                                              else if(P33==0)
                                              {
                                                      //开始计时并对标志位进行置位
                                                      TimerCmd(TIM1 , enable);
                                                      triggerFlag = 1;
                                              }
                                      }
                                      break;
                              }       
                      }
              }
              #endif
 464          
 465          //中断实验
 466          #ifdef INTERRUPT_EXP
              
              //中断实验状态指示枚举变量类型
              typedef enum
              {
                      itExp1,
                      itExp2,
                      itExp3
              }itStatus_t;
              
              //LED状态知识标志位
              unsigned char LedItStatus = 0;
              unsigned char itTimes = 0;
              
              void main(void)
              {
                      //中断状态指示枚举变量
                      itStatus_t idata itStatus = itExp3;
                      
                      //定时器初始化结构体
                      timeMode_t timeMode ={0};
                      
                      //初始化定时器
C51 COMPILER V9.56.0.0   MAIN                                                              11/06/2017 22:09:35 PAGE 9   

                      timeMode.isGateCrl = noGateCrl;
                      timeMode.timeWorkMode = timer;
                      timeMode.timeTriggerMode = innerTrigger;
                      timeMode.timerMode = halfWordAutoReload;
                      
                      TimeInit(TIM0 , timeMode ,5000, 3);
                      
                      //使能定时器中断
                      TimerOverFlowItInit(TIM0 , enable);
                      
                      //使能外部中断0
                      IT0 = 1;
                      
              
                      while(1)
                      {
                              //每20ms循环一次
                              DelayMs(20);
                              //根据不同中断中的标志切换LED的状态
                              switch(itStatus)
                              {
                                      case itExp1:
                                              if(LedItStatus)
                                              {
                                                      Flow(200);
                                              }
                                              else
                                              {
                                                      BlinkIn4(300);
                                              }
                                      break;
                                      case itExp2:
                                              if(LedItStatus)
                                              {
                                                      Flow(200);
                                              }
                                              else
                                              {
                                                      BlinkIn4(300);
                                              }
                                      break;
                                      case itExp3:
                                              if(LedItStatus)
                                              {
                                                      Flow(200);
                                              }
                                              else
                                              {
                                                      BlinkIn4(300);
                                              }
                                      break;
                              }               
                      }
              }
              
              #endif
 545          
 546          //数据储存器实验
 547          #ifdef DATA_MEMORY_TEST
              void main(void)
              {
                      //循环用计数变量
C51 COMPILER V9.56.0.0   MAIN                                                              11/06/2017 22:09:35 PAGE 10  

                      unsigned char i = 0;
                      //对P1IO的输出状态进行初始化
                      P1 = 0x00;
                      //延时20ms
                      DelayMs(20);
                      while(1)
                      {
                              //配置辅助寄存器
                              AUXR = 0x8e;
                              //对数据进行赋值和显示
                              for(i = 0 ; i < DIRECT_ACCESS_SIZE;i++)
                              {
                                      directAccess[i] = i;
                                      LEDShowInt(directAccess[i]);
                                      DelayMs(300);
                              }
                              for(i = 0; i< BIT_ACCESS_SIZE ; i++)
                              {
                                      bitAccess[i] = 255 - i;
                                      LEDShowInt(bitAccess[i]);
                                      DelayMs(300);           
                              }
                              for(i = 0; i< INDIRECT_ACCESS_SIZE ; i++)
                              {
                                      indirectAccess[i] = 128 + i;
                                      LEDShowInt(indirectAccess[i]);
                                      DelayMs(300);           
                              }
                              for(i = 0; i< PAGE_ACCESS_SIZE ; i++)
                              {
                                      pageAccess[i] = i;
                                      LEDShowInt(pageAccess[i]);
                                      DelayMs(300);           
                              }
                              
                              for(i = 0; i< OUTER_MEM_IN_MCU_SIZE ; i++)
                              {
                                      outerMemInMCU[i] = i;
                                      LEDShowInt(outerMemInMCU[i]);
                                      DelayMs(300);           
                              }
                              //配置辅助寄存器禁止片内扩展RAM区
                              AUXR = 0x02;
                              for(i = 0; i< OUTER_EXTEND_MEM_SIZE ; i++)
                              {
                                      outerExtendMem[i] = 128 - i;
                                      LEDShowInt(outerExtendMem[i]);
                                      DelayMs(300);           
                              }               
                      }
              }
              #endif
 603          
 604          #ifdef UART_EXP
 605          unsigned char UART1Recieve = 0;
 606          
 607          void main(void)
 608          {
 609   1      //      //对P1IO的输出状态进行初始化
 610   1              
 611   1              UARTMode_t UARTInitStruct = {0};
 612   1              
C51 COMPILER V9.56.0.0   MAIN                                                              11/06/2017 22:09:35 PAGE 11  

 613   1              P1 = 0x00;
 614   1              
 615   1              UARTInitStruct.UARTMode = UART_MODE_1;
 616   1              UARTInitStruct.UARTIsMulti = 0;
 617   1              UARTInitStruct.isUARTBaudrateDouble = UART_BAUDRATE_NORMAL;
 618   1              UARTInitStruct.itPriority = 0;
 619   1              
 620   1              UARTInit(UART1,UARTInitStruct,9600);
 621   1              
 622   1              while(1)
 623   1              {
 624   2                      DelayMs(20);
 625   2                      
 626   2                      UARTSendByte(UART1,84);
 627   2                      
 628   2                      LEDShowInt(UART1Recieve);
 629   2                      
 630   2              }
 631   1      }
 632          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     83    ----
   CONSTANT SIZE    =      4    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
