C51 COMPILER V9.56.0.0   MAIN                                                              12/14/2017 00:45:11 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRIN
                    -T(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "HD7279.h"
   2          #include "delay.h"
   3          #include "main.h"
   4          #include "89C51_it.h"
   5          
   6          #ifndef DATA_MEMORY_TEST
   7          
   8          #include "8255.h"
   9          #include "basicIO.h"
  10          #include "decode.h"
  11          #include "p1IO.h"
  12          #include "timer.h"
  13          #include "usart.h"
  14          #include "8254.h"
  15          #include "stepMotor.h"
  16          #include "pwm.h"
  17          #include "brushDcMotor.h"
  18          
  19          #endif
  20          
  21          #ifdef DATA_MEMORY_TEST
              
              #include "dataMemory.h"
              
              #endif
  26          
  27          //键盘与LED实验
  28          #ifdef KEY_LED_EXP
              //键盘与LED实验状态枚举变量
              typedef enum
              {
                      //循环左移
                      rollingLeft,
                      //循环右移
                      rollingRight,
                      //所有数码管显示按键输入的数字（0~9）
                      showKeyNumTogether,
                      //数码管显示按键输入数字并在每次输入后左移一位
                      inputRoll2Left,
                      //空闲状态
                      idle
              }ledStatus_t;
              
              void main(void)
              {
              //循环移位的周期数宏定义
              #define ROLL_PERIOD (15)
                      //状态指示变量
                      ledStatus_t idata ledStatus = inputRoll2Left;
                      //循环用计数变量
                      unsigned char i,j = 0;
                      //按键状态，没有按下时为0xff，按下时为按下按键的编号
                      unsigned char keyState = 0;
                      //循环移位周期变量
C51 COMPILER V9.56.0.0   MAIN                                                              12/14/2017 00:45:11 PAGE 2   

                      unsigned char rollPeriod = ROLL_PERIOD;
                      //按键是否按下标志位
                      unsigned char keyFlag = 0;
                      while(1)
                      {
                              //每隔20ms循环一次
                              DelayMs(20);
              
                              //读取按键状态
                              keyState = KeyRead();
              
                              switch(ledStatus)
                              {
                                      //数码管显示内容循环左移
                                      case rollingLeft:
                                              //没有按键按下时循环向左滚动
                                              if(keyState==0xff)
                                              {
                                                      rollPeriod--;
                                                      if(rollPeriod == 0)
                                                      {
                                                              rollPeriod = ROLL_PERIOD;
                                                              //每间隔一个周期发送一个左移命令
                                                              HD7279SendByte(RTL_CYCLE);
                                                      }
                                              }
                                              //按下KEY10时进入所有数码管显示同一数字状态
                                              else if(keyState == KEY10)
                                              {
                                                      rollPeriod = ROLL_PERIOD;
                                                      HD7279SendByte(CMD_RESET);
                                                      ledStatus = showKeyNumTogether;
                                              }
                                      break;
                                      //数码管显示内容循环右移
                                      case rollingRight:
                                              //没有按键按下时数码管显示内容循环右移
                                              if(keyState == 0xff)
                                              {
                                                      rollPeriod--;
                                                      if(rollPeriod == 0)
                                                      {
                                                              rollPeriod = ROLL_PERIOD;
                                                              HD7279SendByte(RTR_CYCLE);
                                                      }
                                              }
                                              //按下KEY10时进入所有数码管显示同一数字状态
                                              else if(keyState == KEY10)
                                              {
                                                      rollPeriod = ROLL_PERIOD;
                                                      HD7279SendByte(CMD_RESET);
                                                      ledStatus = showKeyNumTogether;                         
                                              }
                                      break;
                                      //所有数码管一通显示按下按键对应数字
                                      case showKeyNumTogether:
                                              //根据按键状态显示数字（按键编号与数字对应）
                                              switch(keyState)
                                              {
                                                      case KEY0:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
C51 COMPILER V9.56.0.0   MAIN                                                              12/14/2017 00:45:11 PAGE 3   

                                                                      LedWrite(0x97 - i, realCode[0]);
                                                              }
                                                      break;
                                                      case KEY1:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[1]);
                                                              }
                                                      break;
                                                      case KEY2:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[2]);
                                                              }
                                                      break;
                                                      case KEY3:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[3]);
                                                              }
                                                      break;
                                                      case KEY4:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[4]);
                                                              }                                       
                                                      break;
                                                      case KEY5:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[5]);
                                                              }                                       
                                                      break;
                                                      case KEY6:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[6]);
                                                              }                                       
                                                      break;
                                                      case KEY7:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[7]);
                                                              }                                       
                                                      break;
                                                      case KEY8:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[8]);
                                                              }                                       
                                                      break;
                                                      case KEY9:
                                                              for(i = 0 ; i < 8 ; i++)
                                                              {
                                                                      LedWrite(0x97 - i, realCode[9]);
                                                              }                                       
                                                      break;
                                                      default:
                                                      break;
                                              }       
                                      break;
                                              //每次按键时左移并在最后一位显示对应数字
C51 COMPILER V9.56.0.0   MAIN                                                              12/14/2017 00:45:11 PAGE 4   

                                      case inputRoll2Left:
                                              if(keyState!=0xff&&keyFlag==0)
                                              {
                                                      //发送不循环左移命令
                                                      HD7279SendByte(RTL_UNCYL);
                                                      //根据按键状态在最后一位显示对应数字
                                                      switch(keyState)
                                                      {
                                                              case KEY0:
                                                                      LedWrite(LED1, realCode[0]);
                                                              break;
                                                              case KEY1:
                                                                      LedWrite(LED1, realCode[1]);
                                                              break;
                                                              case KEY2:
                                                                      LedWrite(LED1, realCode[2]);
                                                              break;
                                                              case KEY3:
                                                                      LedWrite(LED1, realCode[3]);
                                                              break;
                                                              case KEY4:
                                                                      LedWrite(LED1, realCode[4]);
                                                              break;
                                                              case KEY5:
                                                                      LedWrite(LED1, realCode[5]);
                                                              break;
                                                              case KEY6:
                                                                      LedWrite(LED1, realCode[6]);
                                                              break;
                                                              case KEY7:
                                                                      LedWrite(LED1, realCode[7]);
                                                              break;
                                                              case KEY8:
                                                                      LedWrite(LED1, realCode[8]);
                                                              break;
                                                              case KEY9:
                                                                      LedWrite(LED1, realCode[9]);
                                                              break;
                                                              default:
                                                              break;
                                                      }
                                                      //对按键状态进行置位
                                                      keyFlag = 1;
                                              }
                                              //当没有按键按下时对按键状态进行复位
                                              if(keyState == 0xff&&keyFlag == 1)
                                              {
                                                      keyFlag = 0;
                                              }
                                                      
                                      break;
                                      //空闲状态
                                      case idle:
                                              
                                      break;
                                      default:
                                      break;
                              }
                      }
              }
              #endif
 240          
C51 COMPILER V9.56.0.0   MAIN                                                              12/14/2017 00:45:11 PAGE 5   

 241          //简单IO实验
 242          #ifdef BASIC_IO_EXP
              
              void main(void)
              {
                      //IO输入记录变量
                      unsigned char ioInput = 0;
                      //循环计数用变量
                      unsigned char i = 0;
                      
                      while(1)
                      {
                              //每20MS循环一次
                              DelayMs(20);
                              
                              //从74LS245地址读取简单IO输入
                              ioInput = chip245Adress;
                      
                              //将简单IO输入输出到74LS374
                              chip374Adress = ~ioInput;
                      
                              //在数码管上显示简单IO输入状态 
                              for(i = 0 ; i < 8 ; i++)
                              {
                                      if((ioInput>>i)&0x01)
                                      {
                                              LedWrite(0x97 - 7 + i, realCode[1]);
                                      }
                                      else
                                      {
                                              LedWrite(0x97 - 7 + i, realCode[0]);
                                      }
                              }
                      }
              }
              #endif
 277          
 278          //译码器实验
 279          #ifdef DECODE_EXP
              
              void main(void)
              {
                      //译码实验输出变量
                      unsigned char ioOutput = 0;
                      //计数用变量
                      unsigned short timeCounter = 0;
                      while(1)
                      {
                              //每20ms循环一次
                              DelayMs(20);
                              
                              //记录循环次数
                              timeCounter++;
                              timeCounter%=20;
                              
                              //每隔一定周期将输出输出到不同的地址
                              if(timeCounter/10)
                              {
                                      decodeAdress1 = ioOutput;
                              }
                              else
                              {
C51 COMPILER V9.56.0.0   MAIN                                                              12/14/2017 00:45:11 PAGE 6   

                                      decodeAdress2 = ioOutput;
                              }       
                      }
              }
              #endif
 308          
 309          //通用IOP1实验
 310          #ifdef P1_IO_EXP
              //P1IO实验状态指示枚举变量
              typedef enum
              {
                      //四个LED灯
                      blinkIn4,
                      //流水灯 
                      flow,
                      //LED灯指示开关状态
                      showInput,
                      //空闲状态
                      p1Idle
              }p1IOStatus_t;
              
              void main(void)
              {
                      //状态指示变量
                      p1IOStatus_t idata p1IOStatus = flow;
                      while(1)
                      {
                              //每20ms循环一次
                              DelayMs(20);
                              
                              switch(p1IOStatus)
                              {
                                      //四个LED一组闪烁
                                      case blinkIn4:
                                              BlinkIn4(500);
                                      break;
                                      //流水灯
                                      case flow:
                                              Flow(500);
                                      break;
                                      //将P10~P13输入输出到P14~P17，用输入控制LED的亮灭
                                      case showInput:
                                              ShowInput();
                                      break;
                                      case p1Idle:
                                      break;
                                      default:
                                      break;
                              }       
                      }
              }
              #endif
 355          
 356          //定时器实验
 357          #ifdef TIMER_EXP
              
              //状态指示枚举变量类型
              typedef enum
              {
                      timerExp1,
                      timerExp2,
                      timerExp3       
C51 COMPILER V9.56.0.0   MAIN                                                              12/14/2017 00:45:11 PAGE 7   

              }timerStatus_t;
              
              void main(void)
              {
                      //状态指示变量
                      timerStatus_t idata timerStatus = timerExp3;
                      
                      //实验三是否触发指示变量
                      unsigned char triggerFlag = 0;
                      
                      //实验三脉冲宽度变量
                      unsigned short pulseWidth = 0;
                      
                      //定时器初始化结构体 
                      timeMode_t timeMode ={0};
                      
                      //对结构体进行赋值
                      timeMode.isGateCrl = noGateCrl;
                      timeMode.timeWorkMode = timer;
                      timeMode.timeTriggerMode = innerTrigger;
                      timeMode.timerMode = halfWordAutoReload;
                      
                      //初始化定时器
                      TimeInit(TIM0 , timeMode ,200, TIMERUS);
              
                      //对结构体进行赋值
                      timeMode.isGateCrl = noGateCrl;
                      timeMode.timeWorkMode = counter;
                      timeMode.timeTriggerMode = outerTrigger;
                      timeMode.timerMode = byteAutoReload;
                      //初始化定时器
                      TimeInit(TIM1 , timeMode ,0, TIMERUS);
                      TimerCmd(TIM1 , disable);
                      TH1 = 0xfb;
                      TL1 = 0xfb;
                      TimerCmd(TIM1 ,enable);
                      
                      if(timerStatus==timerExp3)
                      {
                              //对结构体进行赋值      
                              timeMode.isGateCrl = GateCrl;
                              timeMode.timeWorkMode = timer;
                              timeMode.timeTriggerMode = innerTrigger;
                              timeMode.timerMode = halfWordNotReload; 
                              //初始化定时器    
                              TimeInit(TIM1 , timeMode ,65535, 1);
                              TimerCmd(TIM1 , disable);
                      }               
                      while(1)
                      {
                              switch(timerStatus)
                              {
                                      //在P1.0引脚上生成一个周期为400uS的方波
                                      case timerExp1:
                                              if(TimerGetOverFlowITFlag(TIM0))
                                              {
                                                      P10=!P10;
                                                      TimerClearOverFlowFlag(TIM0);
                                              }
                                      break;
                                      //通过定时器技术控制LED的亮灭
                                      case timerExp2:
C51 COMPILER V9.56.0.0   MAIN                                                              12/14/2017 00:45:11 PAGE 8   

                                              {
                                                      if(TimerGetOverFlowITFlag(TIM1))
                                                      {
                                                              P10=!P10;
                                                              TimerClearOverFlowFlag(TIM1);
                                                      }                                                       
                                              }
                                      break;
                                      //测量脉冲宽度
                                      case timerExp3:
                                      {
                                              //输入为高
                                              if(P33==1)
                                              {
                                                      //失能定时器 
                                                      TimerCmd(TIM1 , disable);
                                                      //如果之前被触发计算脉冲宽度
                                                      if(triggerFlag==1)
                                                      {
                                                              //从定时器寄存器中读出脉冲宽度
                                                              pulseWidth = ((TH1<<8)|TL1);
                                                              //在数码管上显示脉冲宽度
                                                              LEDShowInt(pulseWidth);
                                                              //复位标志位及寄存器
                                                              triggerFlag = 0;
                                                              TH1=0;
                                                              TL1=0;
                                                      }
                                              }
                                              //输入为低
                                              else if(P33==0)
                                              {
                                                      //开始计时并对标志位进行置位
                                                      TimerCmd(TIM1 , enable);
                                                      triggerFlag = 1;
                                              }
                                      }
                                      break;
                              }       
                      }
              }
              #endif
 469          
 470          //中断实验
 471          #ifdef INTERRUPT_EXP
              
              //中断实验状态指示枚举变量类型
              typedef enum
              {
                      itExp1,
                      itExp2,
                      itExp3
              }itStatus_t;
              
              //LED状态知识标志位
              unsigned char LedItStatus = 0;
              unsigned char itTimes = 0;
              
              void main(void)
              {
                      //中断状态指示枚举变量
                      itStatus_t idata itStatus = itExp3;
C51 COMPILER V9.56.0.0   MAIN                                                              12/14/2017 00:45:11 PAGE 9   

                      
                      //定时器初始化结构体
                      timeMode_t timeMode ={0};
                      
                      //初始化定时器
                      timeMode.isGateCrl = noGateCrl;
                      timeMode.timeWorkMode = timer;
                      timeMode.timeTriggerMode = innerTrigger;
                      timeMode.timerMode = halfWordAutoReload;
                      
                      TimeInit(TIM0 , timeMode ,5000, TIMERUS);
                      
                      //使能定时器中断
                      TimerOverFlowItInit(TIM0 , enable);
                      
                      //使能外部中断0
                      IT0 = 1;
                      
              
                      while(1)
                      {
                              //每20ms循环一次
                              DelayMs(20);
                              //根据不同中断中的标志切换LED的状态
                              switch(itStatus)
                              {
                                      case itExp1:
                                              if(LedItStatus)
                                              {
                                                      Flow(200);
                                              }
                                              else
                                              {
                                                      BlinkIn4(300);
                                              }
                                      break;
                                      case itExp2:
                                              if(LedItStatus)
                                              {
                                                      Flow(200);
                                              }
                                              else
                                              {
                                                      BlinkIn4(300);
                                              }
                                      break;
                                      case itExp3:
                                              if(LedItStatus)
                                              {
                                                      Flow(200);
                                              }
                                              else
                                              {
                                                      BlinkIn4(300);
                                              }
                                      break;
                              }               
                      }
              }
              
              #endif
 550          
C51 COMPILER V9.56.0.0   MAIN                                                              12/14/2017 00:45:11 PAGE 10  

 551          //数据储存器实验
 552          #ifdef DATA_MEMORY_TEST
              void main(void)
              {
                      //循环用计数变量
                      unsigned char i = 0;
                      //对P1IO的输出状态进行初始化
                      P1 = 0x00;
                      //延时20ms
                      DelayMs(20);
                      while(1)
                      {
                              //配置辅助寄存器
                              AUXR = 0x8e;
                              //对数据进行赋值和显示
                              for(i = 0 ; i < DIRECT_ACCESS_SIZE;i++)
                              {
                                      directAccess[i] = i;
                                      LEDShowInt(directAccess[i]);
                                      DelayMs(300);
                              }
                              for(i = 0; i< BIT_ACCESS_SIZE ; i++)
                              {
                                      bitAccess[i] = 255 - i;
                                      LEDShowInt(bitAccess[i]);
                                      DelayMs(300);           
                              }
                              for(i = 0; i< INDIRECT_ACCESS_SIZE ; i++)
                              {
                                      indirectAccess[i] = 128 + i;
                                      LEDShowInt(indirectAccess[i]);
                                      DelayMs(300);           
                              }
                              for(i = 0; i< PAGE_ACCESS_SIZE ; i++)
                              {
                                      pageAccess[i] = i;
                                      LEDShowInt(pageAccess[i]);
                                      DelayMs(300);           
                              }
                              
                              for(i = 0; i< OUTER_MEM_IN_MCU_SIZE ; i++)
                              {
                                      outerMemInMCU[i] = i;
                                      LEDShowInt(outerMemInMCU[i]);
                                      DelayMs(300);           
                              }
                              //配置辅助寄存器禁止片内扩展RAM区
                              AUXR = 0x02;
                              for(i = 0; i< OUTER_EXTEND_MEM_SIZE ; i++)
                              {
                                      outerExtendMem[i] = 128 - i;
                                      LEDShowInt(outerExtendMem[i]);
                                      DelayMs(300);           
                              }               
                      }
              }
              #endif
 608          
 609          #ifdef UART_EXP
              unsigned char UART1Recieve = 0;
              
              void main(void)
C51 COMPILER V9.56.0.0   MAIN                                                              12/14/2017 00:45:11 PAGE 11  

              {
              //      //对P1IO的输出状态进行初始化
                      
                      UARTMode_t UARTInitStruct = {0};
                      
                      P1 = 0x00;
                      
                      UARTInitStruct.UARTMode = UART_MODE_1;
                      UARTInitStruct.UARTIsMulti = 0;
                      UARTInitStruct.isUARTBaudrateDouble = UART_BAUDRATE_NORMAL;
                      UARTInitStruct.itPriority = 0;
                      
                      UARTInit(UART1,UARTInitStruct,9600);
                      
                      while(1)
                      {
                              DelayMs(20);
                              
                              UARTSendByte(UART1,84);
                              
                              LEDShowInt(UART1Recieve);
                              
                      }
              }
              #endif
 638          
 639          #ifdef IO8255_EXP
              
              void main(void)
              {
                      IO8255Init_t IO8255InitStuct = {0};
                      unsigned char pinNum = 0;
                      
                      IO8255InitStuct.portAInit.IO8255Mode = IO8255_MODE0;
                      IO8255InitStuct.portAInit.IOInOrOut = IO8255_INPUT;
              
                      IO8255InitStuct.portBInit.IO8255Mode = IO8255_MODE0;
                      IO8255InitStuct.portBInit.IOInOrOut = IO8255_OUTPUT;
                      
                      IO8255InitStuct.portCUInit.IOInOrOut = IO8255_OUTPUT;
                      IO8255InitStuct.portCLInit.IOInOrOut = IO8255_OUTPUT;
              
                      IO8255Init(IO8255InitStuct);
                      
                      while(1)
                      {
                              for(pinNum=0 ; pinNum < 8 ; pinNum++)
                              {
                                      IO8255SetBit(PortC , pinNum , IO8255ReadBit(PortA , pinNum));
                              }
              
                      }
              }
              
              #endif
 668          
 669          #ifdef TIMER_8254_EXP
              
              void main(void)
              {
                      CLK_DIV = (CLK_DIV&0x3f)|0x40;
                      
C51 COMPILER V9.56.0.0   MAIN                                                              12/14/2017 00:45:11 PAGE 12  

                      Timer8254CounterModeInit(timer8254Timer0, 10000);
                      
                      Timer8254PrescalerModeInit(timer8254Timer1, 10);
              
                      while(1)
                      {
                              LEDShowInt(Timer8254GetCounter(timer8254Timer0));
                              DelayMs(20);
                      }
              }
              
              #endif
 687          
 688          #ifdef STEPMOTOR_EXP
 689          
 690          extern float xdata actSpeed;
 691          void main(void)
 692          {
 693   1      //      StepMotorPinInit();
 694   1      //      while(1)
 695   1      //      {
 696   1      //              StepMotorSpeedControl(PI);
 697   1      //      }
 698   1              //定时器初始化结构体 
 699   1              timeMode_t xdata timeMode ={0};
 700   1              
 701   1              //对结构体进行赋值
 702   1              timeMode.isGateCrl = noGateCrl;
 703   1              timeMode.timeWorkMode = timer;
 704   1              timeMode.timeTriggerMode = innerTrigger;
 705   1              timeMode.timerMode = halfWordAutoReload;
 706   1              
 707   1              //初始化定时器
 708   1              TimeInit(TIM0 , timeMode ,100000, TIMERUS);
 709   1              
 710   1              TimerOverFlowItInit(TIM0 , enable);
 711   1      
 712   1                      //对结构体进行赋值
 713   1              timeMode.isGateCrl = noGateCrl;
 714   1              timeMode.timeWorkMode = counter;
 715   1              timeMode.timeTriggerMode = innerTrigger;
 716   1              timeMode.timerMode = halfWordAutoReload;
 717   1              
 718   1              //初始化定时器
 719   1              TimeInit(TIM1 , timeMode ,0, TIMERUS);
 720   1              
 721   1              PWM0Init();
 722   1              
 723   1              CCP1Init();
 724   1              
 725   1              PWM0SetCompare(0.2f);
 726   1              PWMCmd(enable);
 727   1              
 728   1              DelayMs(5000);
 729   1      
 730   1              while(1)
 731   1              {
 732   2                      DelayMs(20);
 733   2                      MotorVelCrl(50.0f,actSpeed);
 734   2                      LEDShowFloat(actSpeed); 
 735   2                      LedWrite(0x97,0x4F);
 736   2              }
C51 COMPILER V9.56.0.0   MAIN                                                              12/14/2017 00:45:11 PAGE 13  

 737   1      }
 738          
 739          #endif
 740          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    220    ----
   CONSTANT SIZE    =      4    ----
   XDATA SIZE       =   ----       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
